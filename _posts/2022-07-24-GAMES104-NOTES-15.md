---
layout: article
title: GAMES104课程笔记15-Gameplay Complexity and Building Blocks
tags: ["GAMES104", "CG"]
key: GAMES104-15
aside:
  toc: true
sidebar:
  nav: GAMES104
---

> 这个系列是GAMES104-现代游戏引擎：从入门到实践([GAMES 104: Modern Game Engine-Theory and Practice](https://games104.boomingtech.com/en/))的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍游戏引擎中的玩法系统。
<!--more-->

## Overview

玩法系统是游戏引擎最重要的部分，它是区分游戏引擎和渲染器以及物理引擎的核心。实际上玩法系统往往会贯穿整个游戏引擎，与引擎的其它系统进行交互，这样才能满足游戏设计师的需求。

<div align=center>
<img src="https://i.imgur.com/M4uTyxk.png" width="80%">
</div>

另一方面现代游戏的玩法是极其丰富的，即使是同一类型的游戏也具有多种多样的表现形式。这些丰富的游戏内容都需要通过玩法系统来进行实现。

<div align=center>
<img src="https://i.imgur.com/n8dyUHT.png" width="80%">
</div>

而在游戏行业中玩法系统还面临着快速迭代的问题，同一个游戏的核心玩法在开发运营初期和后期可能会有着巨大的差别。因此玩法系统在设计时也需要考虑需求变更和快速迭代。

<div align=center>
<img src="https://i.imgur.com/zooQ5OC.png" width="80%">
</div>

## Event Mechanism

玩法系统的核心是**事件机制(event mechanism)**，在游戏世界中不同类型的GO会通过事件/消息的方式进行通信从而驱动游戏世界的运行。

<div align=center>
<img src="https://i.imgur.com/MWD6VBi.png" width="80%">
<img src="https://i.imgur.com/tJkUrTI.png" width="80%">
</div>

### Publish-Subscribe Pattern

在游戏引擎中一般会使用**publish-subscribe**这样的模式来实现具体的通信过程。在publish-subscribe模式中每个GO有着自己的publish功能来向其它GO发送事件，同时自身的subscribe功能来实现接收事件以及相应的反馈。当然在publish-subscribe模式中还需要一个**event dispatcher**来执行高效的事件派送。因此在publish-subscribe模式中的三要素为**事件定义(event definition)**、**注册回调(callback registration)**以及**事件派送(event dispatching)**。

<div align=center>
<img src="https://i.imgur.com/2nVAJad.png" width="80%">
<img src="https://i.imgur.com/DfwNkkL.png" width="80%">
</div>

### Event Definition

事件定义是实现事件机制的第一步，最简单的定义方式是为事件定义一个类型以及相应的参数。

<div align=center>
<img src="https://i.imgur.com/uCJTv82.png" width="80%">
</div>

因此我们可以使用继承的方式来实现不同类型事件的定义。但这种方式的缺陷在于玩法系统往往是由设计师来实现的，而对于游戏引擎来说一般无法由程序员事先确定。

<div align=center>
<img src="https://i.imgur.com/o77FA7j.png" width="80%">
</div>

在现代游戏引擎中会使用反射和代码渲染的方式来允许设计师自定义事件类型和相关的数据。

<div align=center>
<img src="https://i.imgur.com/oBNZmKu.png" width="80%">
</div>

### Callback Registration

当GO接收到事件后就会激活调用相应的回调函数来改变自身的状态，而为了正确地使用回调函数则首先需要对不同的回调函数进行注册。

<div align=center>
<img src="https://i.imgur.com/adtFj5v.png" width="80%">
</div>

回调函数的一大特点在于它的注册和执行往往是分开的。这一特点可能会导致回调函数调用时相关的一些GO可能已经结束了生命周期，因此回调函数的安全性是整个事件系统的一大难题。

<div align=center>
<img src="https://i.imgur.com/iYe01qG.png" width="80%">
<img src="https://i.imgur.com/5N8opi1.png" width="80%">
</div>

为了处理这样的问题我们可以使用**强引用(strong reference)**这样的机制来锁定相关GO的生命周期。强引用会保证所有和回调函数相关的资源在回调函数调用前不会被回收，从而确保系统的安全。

<div align=center>
<img src="https://i.imgur.com/Oo0C0MI.png" width="80%">
</div>

当然强引用的方式在一些场景下可能是不合适的，很多时候我们希望某些资源可以正确的卸载掉。因此我们还可以使用**弱引用(weak reference)**的机制在调用回调函数时判断资源是否已经被卸载掉。当然弱引用机制的滥用可能会影响整个系统的性能。

<div align=center>
<img src="https://i.imgur.com/UnuKH6g.png" width="80%">
</div>

### Event Dispatching

事件会通过分发系统来实现消息的传递。由于游戏中每一时刻往往存在着成千上万个GO和相应的回调函数，我们需要一个非常高效的分发系统才能保证游戏的实时性。

<div align=center>
<img src="https://i.imgur.com/bOB6gmu.png" width="80%">
</div>

最简单的分发机制是把消息瞬时发出去。这种方式的缺陷在于它会阻塞前一个函数的执行，从而形成一个巨大的调用栈使得系统难以调试；此外很多回调函数在执行时会申请一些额外的资源，这就容易导致游戏的帧率很难稳定。

<div align=center>
<img src="https://i.imgur.com/eiuBCwp.png" width="80%">
<img src="https://i.imgur.com/6OzCzgs.png" width="80%">
<img src="https://i.imgur.com/bhRBpjP.png" width="80%">
<img src="https://i.imgur.com/ohtMhb8.png" width="80%">
</div>

现代游戏引擎中更常用的分发方式是使用**事件队列(event queue)**来收集当前帧上所有的事件，然后在下一帧再进行分发和处理。

<div align=center>
<img src="https://i.imgur.com/vkJfaKd.png" width="80%">
</div>

由于event queue中有不同类型的事件，因此我们还需要结合序列化和反序列化的操作来进行存储。

<div align=center>
<img src="https://i.imgur.com/Lpqlllo.png" width="80%">
</div>

event queue一般会使用ring buffer这样的数据结构来实现，这样可以重用一块统一的内存空间来提升效率。

<div align=center>
<img src="https://i.imgur.com/I3nS0JC.png" width="80%">
</div>

现代游戏引擎中往往会同时有多个不同的event queue来处理不同类型的事件，每个queue用来保存一些相对独立的事件。这种方式可以便于我们进行调试，也可以提升系统的性能。

<div align=center>
<img src="https://i.imgur.com/HL9kTFx.png" width="80%">
</div>

当然event queue也有一些自身的问题。首先event queue无法保证event执行的顺序，同时对于一些实时性的事件event queue可能会导致执行的延误。

<div align=center>
<img src="https://i.imgur.com/sF6elEf.png" width="80%">
<img src="https://i.imgur.com/qAxWa7o.png" width="80%">
</div>

## Game Logic

## Visual Script

## Character, Control and Camera

## Reference

- [Lecture 15：Gameplay Complexity and Building Blocks](https://www.bilibili.com/video/BV1u34y1H7jd?vd_source=7a2542c6c909b3ee1fab551277360826)