---
layout: article
title: GAMES104课程笔记16-Basic Artificial Intelligence
tags: ["GAMES104", "CG"]
key: GAMES104-16
aside:
  toc: true
sidebar:
  nav: GAMES104
---

> 这个系列是GAMES104-现代游戏引擎：从入门到实践([GAMES 104: Modern Game Engine-Theory and Practice](https://games104.boomingtech.com/en/))的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍游戏AI的基本内容。
<!--more-->

## Navigation

游戏AI是玩法系统重要的组成部分，其中最基本的功能是允许玩家选择目的地进行**导航(navigation)**。

<div align=center>
<img src="https://i.imgur.com/NowXwKg.png" width="80%">
</div>

导航算法需要考虑游戏地图的不同表达形式，然后寻找到从起点到目的地的最短路径，有时还需要结合一些其它算法来获得更加光滑的路线。

<div align=center>
<img src="https://i.imgur.com/gYKOfzy.png" width="80%">
</div>

### Map Representation

因此我们首先需要考虑游戏中如何来表达地图，我们可以认为地图是玩家和NPC可以行动的区域。游戏中常见的地图形式包括路点**网络图(waypoint network)**、**网格(grid)**、**寻路网格(navigation mesh)**以及**八叉树(sparse voxel octree)**等。

<div align=center>
<img src="https://i.imgur.com/OYDu8iH.png" width="80%">
<img src="https://i.imgur.com/kPOhH7c.png" width="80%">
</div>

#### Waypoint Network

waypoint network是早期游戏中最常用的地图表示方式。我们可以把地图上的路标使用节点来表示，然后可通行的节点使用边来连接起来就形成了一个网络结构。

<div align=center>
<img src="https://i.imgur.com/qXDILJ1.png" width="80%">
</div>

当玩家需要进行导航时只需要选择距离起点和目的地最近的两个路标，然后在网络图上进行导航即可。

<div align=center>
<img src="https://i.imgur.com/aRJu9E2.png" width="80%">
</div>

waypoint network的优势在于它非常易于实现，而且我们有成熟的路径搜索算法可以直接应用在网络图上；但它的缺陷在于路网图需要不断地和开发中的地图进行更新，而且使用路网进行导航时角色会倾向于沿路径中心前进而无法利用两边的通道。因此在现代游戏中路网的应用并不是很多。

<div align=center>
<img src="https://i.imgur.com/CWHulfR.png" width="80%">
</div>

#### Grid

网格同样是表达游戏地图的经典方法，常用的网格地图包括方格地图、三角形地图或是六边形地图等。

<div align=center>
<img src="https://i.imgur.com/rZfpwW8.png" width="80%">
</div>

使用网格来表示地图时只需要把不可通行的区域遮挡住就可以了，因此网格可以动态地反映地图环境的变化。

<div align=center>
<img src="https://i.imgur.com/4W2KL5B.png" width="80%">
</div>

显然网格地图同样非常容易实现，而且支持动态更新，也便于调试；而它的缺陷在于网格地图的精度受制于地图分辨率，而且比较占用存储空间，最严重的问题是网格很难表示重叠区域之间的连接关系。

<div align=center>
<img src="https://i.imgur.com/d45U0hV.png" width="80%">
</div>

#### Navigation Mesh

为了克服网格地图的这些问题，人们开发出了寻路网格这样的地图表达形式。在寻路网格中可通行的区域会使用多边形来进行覆盖，这样可以方便地表达不同区域直接相互连接的拓扑关系。

<div align=center>
<img src="https://i.imgur.com/72FC5tn.png" width="80%">
<img src="https://i.imgur.com/vgf8AlW.png" width="80%">
</div>

在寻路网格中我们还会要求每个多边形都必须是凸多边形，这样才能保证角色在行进中不会穿过网格。

<div align=center>
<img src="https://i.imgur.com/2j6zXlf.png" width="80%">
</div>

寻路网格是现代游戏中广泛应用的地图表达形式，而它的缺陷主要在于生成寻路网格的算法相对比较复杂，而且它无法表达三维空间的拓扑连接关系。

<div align=center>
<img src="https://i.imgur.com/zipSbRi.png" width="80%">
</div>

#### Voxel Voxel Octree

如果要制作三维空间中的地图则可以考虑八叉树这样的数据结构。

<div align=center>
<img src="https://i.imgur.com/3zLpnOL.png" width="80%">
</div>

### Path Finding

得到游戏地图后就可以使用寻路算法来计算路径了，当然无论我们使用什么样的地图表达方式我们首先都需要把游戏地图转换为拓扑地图，然后再使用相应的算法进行寻路。

<div align=center>
<img src="https://i.imgur.com/cnymCfs.png" width="80%">
<img src="https://i.imgur.com/6H0jZIY.png" width="80%">
</div>

#### Depth-First Search

寻路算法的本质是在图上进行搜索，因此我们可以使用**深度优先搜索(depth-first search, DFS)**来进行求解。

<div align=center>
<img src="https://i.imgur.com/WLIiyP2.png" width="80%">
</div>

#### Width-First Search

另一种常用的图搜索算法是**广度优先搜索(width-first search, BSF)**。

<div align=center>
<img src="https://i.imgur.com/qIjB3T4.png" width="80%">
</div>

#### Dijkstra Algorithm

直接使用DFS或是BFS往往是过于低效的，实践中更常用的寻路算法是**Dijkstra算法(Dijkstra algorithm)**：

<div align=center>
<img src="https://i.imgur.com/OetqRny.png" width="80%">
<img src="https://i.imgur.com/3pgWF0B.png" width="80%">
<img src="https://i.imgur.com/4kL80jw.png" width="80%">
</div>

#### A Star

Dijkstra算法可以计算从起始节点出发到图上任意节点的最短路径，但它的缺陷在于图上很多节点对于我们想要计算的路径是没有意义的。因此人们还提出了**A star**算法来进行改进，在A star算法中通过引入一个启发式函数来控制节点访问的倾向性，使得路径的搜索会更倾向于访问目标点。

<div align=center>
<img src="https://i.imgur.com/m9iKxea.png" width="80%">
<img src="https://i.imgur.com/ZQZT7Il.png" width="80%">
</div>

在网格地图中常用的启发函数包括Manhattan距离等。

<div align=center>
<img src="https://i.imgur.com/g99PD7V.png" width="80%">
</div>

而在寻路网格中则可以使用欧氏距离作为启发函数。

<div align=center>
<img src="https://i.imgur.com/q2AkyRE.png" width="80%">
<img src="https://i.imgur.com/3OPi9S4.png" width="80%">
<img src="https://i.imgur.com/CYcj7il.png" width="80%">
</div>

显然启发式算法的设计对于最终计算得到的路径会产生显著的影响。当启发函数的值过低时可能会需要更多次循环才能寻找到路径，而当启发函数值过高时则可能无法找到最短路径。因此在实际应用中需要进行一定的权衡。

<div align=center>
<img src="https://i.imgur.com/uNt3Qqi.png" width="80%">
</div>

### Path Smoothing

### NavMesh Generation

## Steering

## Crowd Simulation

## Sensing

## Classic Decision Making Algorithms

## Reference

- [Lecture 16：Basic Artificial Intelligence (Part I)](https://www.bilibili.com/video/BV19N4y1T7eU?spm_id_from=333.337.search-card.all.click&vd_source=7a2542c6c909b3ee1fab551277360826)
- [Lecture 16：Basic Artificial Intelligence (Part II)](https://www.bilibili.com/video/BV1r34y1J7Sg/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)