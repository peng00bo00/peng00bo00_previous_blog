---
layout: article
title: GAMES104课程笔记20-Data-Oriented Programming and Job System
tags: ["GAMES104", "CG"]
key: GAMES104-20
aside:
  toc: true
sidebar:
  nav: GAMES104
---

> 这个系列是GAMES104-现代游戏引擎：从入门到实践([GAMES 104: Modern Game Engine-Theory and Practice](https://games104.boomingtech.com/en/))的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍面向数据编程以及任务系统在游戏引擎中的应用。
<!--more-->

现代游戏引擎对于性能的需求非常高，为了保证游戏的实时性需要使用大量的高性能编程技术。

<div align=center>
<img src="https://i.imgur.com/n4izpFM.png" width="80%">
</div>

## Basics of Parallel Programming

随着硬件技术的发展，芯片中晶体管的数量已经接近了物理极限。因此在现代计算机中会使用**多核(multi-core)**处理器来进一步提升计算性能。

<div align=center>
<img src="https://i.imgur.com/jJCUbEH.png" width="80%">
</div>

### Process and Thread

**进程(process)**和**线程(thread)**是进行并行编程会涉及到的基本概念。简单来说一个程序就是一个进程，它拥有自己的内存空间；而一个进程可以拥有很多线程，它们会共享进程指向的同一片内存数据。

<div align=center>
<img src="https://i.imgur.com/ZXcQyWy.png" width="80%">
</div>

### Types of Multitasking

对于多核的计算机我们希望能够充分利用不同的计算核心来提升程序的性能。根据处理器管理任务的不同可以把进程调度分为两种：**抢占式(preemptive multitasking)**和**非抢占式(non-preemptive multitasking)**式。preemptive multitasking是由调度器来控制任务的切换，而non-preemptive multitasking则是由任务自身来进行控制。

<div align=center>
<img src="https://i.imgur.com/tdkyo1m.png" width="80%">
</div>

### Thread Context Switch

线程在进行切换时会产生额外的开销，因此在游戏引擎中我们希望尽可能减少线程的上下文切换。

<div align=center>
<img src="https://i.imgur.com/THTA4rT.png" width="80%">
</div>

### Parallel Problems in Parallel Computing

在并行程序中我们希望不同的任务之间互不打扰，只需要在程序最后把所有的计算结果进行汇总就好。这样的程序往往有着非常高的运行效率，比如说Monte Carlo模拟就是典型的例子。不过现实中的程序往往不会这样理想，很多任务之间存在各种相互依赖，这会降低程序的运行效率。

<div align=center>
<img src="https://i.imgur.com/af0Rea9.png" width="80%">
</div>

### Data Race in Parallel Programming

**data race**是编写并行程序中最常见的问题，当不同的线程想要访问并修改同一块内存时就会产生data race。由于线程的调度是不可预料的，data race会导致程序的计算结果出现各种各样的问题。

<div align=center>
<img src="https://i.imgur.com/6XW6ewO.png" width="80%">
</div>

### Blocking Algorithm

处理data race最简单的方式是给程序**上锁(lock)**，这样可以保证同一时间只能有一个线程对指定的内存区域进行访问。锁之间的程序片断称为**critical section**，当某个线程执行critical section时其它需要访问同一内存的线程会被强制等待。

<div align=center>
<img src="https://i.imgur.com/j1n5Zax.png" width="80%">
</div>

尽管使用锁可以保证程序的正确执行，但锁的存在会影响程序的并行性。更严重的是它可能会产生**死锁(dead lock)**的现象从而阻塞程序的运行。因此在编写并行程序时需要注意尽可能减少锁的使用。

<div align=center>
<img src="https://i.imgur.com/h6rClgJ.png" width="80%">
</div>

### Atomic Operation

处理data race的另一种常用方法是使用**原子操作(atomic operation)**。原子操作是硬件层面实现的最基本操作，它无法同时被多个CPU一起执行。利用原子操作可以实现无锁的程序并行，从而极大地提升运行效率。

<div align=center>
<img src="https://i.imgur.com/DaOv4bG.png" width="80%">
<img src="https://i.imgur.com/UaGzzhG.png" width="80%">
</div>

### Complier Reordering Optimizations

另一方面需要注意的是现代编译器对于高级语言是可以进行自动优化的。这种优化可以提升单线程程序的运行效率，但对于多线程的情况则可能会导致一些问题。

<div align=center>
<img src="https://i.imgur.com/h6rClgJ.png" width="80%">
<img src="https://i.imgur.com/JBLswBA.png" width="80%">
</div>

实际上很多的现代芯片出于种种方面的考虑都无法保证多线程情况下编译后代码的执行顺序。

<div align=center>
<img src="https://i.imgur.com/pqU3uW8.png" width="80%">
</div>

## Parallel Framework of Game Engine

## Job System

## Programming Paradigms

## Data-Oriented Programming

## Performance-Sensitive Programming

## Performance-Sensitive Data Arrangements

## Entity Component System

## Reference

- [Lecture 20：Data-Oriented Programming and Job System (Part I)](https://www.bilibili.com/video/BV1EP411V7jx/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)
- [Lecture 20：Data-Oriented Programming and Job System (Part II)](https://www.bilibili.com/video/BV1Md4y1G7zp/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)