---
layout: article
title: GAMES104课程笔记20-Data-Oriented Programming and Job System
tags: ["GAMES104", "CG"]
key: GAMES104-20
aside:
  toc: true
sidebar:
  nav: GAMES104
---

> 这个系列是GAMES104-现代游戏引擎：从入门到实践([GAMES 104: Modern Game Engine-Theory and Practice](https://games104.boomingtech.com/en/))的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍面向数据编程以及任务系统在游戏引擎中的应用。
<!--more-->

现代游戏引擎对于性能的需求非常高，为了保证游戏的实时性需要使用大量的高性能编程技术。

<div align=center>
<img src="https://i.imgur.com/n4izpFM.png" width="80%">
</div>

## Basics of Parallel Programming

随着硬件技术的发展，芯片中晶体管的数量已经接近了物理极限。因此在现代计算机中会使用**多核(multi-core)**处理器来进一步提升计算性能。

<div align=center>
<img src="https://i.imgur.com/jJCUbEH.png" width="80%">
</div>

### Process and Thread

**进程(process)**和**线程(thread)**是进行并行编程会涉及到的基本概念。简单来说一个程序就是一个进程，它拥有自己的内存空间；而一个进程可以拥有很多线程，它们会共享进程指向的同一片内存数据。

<div align=center>
<img src="https://i.imgur.com/ZXcQyWy.png" width="80%">
</div>

### Types of Multitasking

对于多核的计算机我们希望能够充分利用不同的计算核心来提升程序的性能。根据处理器管理任务的不同可以把进程调度分为两种：**抢占式(preemptive multitasking)**和**非抢占式(non-preemptive multitasking)**式。preemptive multitasking是由调度器来控制任务的切换，而non-preemptive multitasking则是由任务自身来进行控制。

<div align=center>
<img src="https://i.imgur.com/tdkyo1m.png" width="80%">
</div>

### Thread Context Switch

线程在进行切换时会产生额外的开销，因此在游戏引擎中我们希望尽可能减少线程的上下文切换。

<div align=center>
<img src="https://i.imgur.com/THTA4rT.png" width="80%">
</div>

### Parallel Problems in Parallel Computing

在并行程序中我们希望不同的任务之间互不打扰，只需要在程序最后把所有的计算结果进行汇总就好。这样的程序往往有着非常高的运行效率，比如说Monte Carlo模拟就是典型的例子。不过现实中的程序往往不会这样理想，很多任务之间存在各种相互依赖，这会降低程序的运行效率。

<div align=center>
<img src="https://i.imgur.com/af0Rea9.png" width="80%">
</div>

### Data Race in Parallel Programming

**data race**是编写并行程序中最常见的问题，当不同的线程想要访问并修改同一块内存时就会产生data race。由于线程的调度是不可预料的，data race会导致程序的计算结果出现各种各样的问题。

<div align=center>
<img src="https://i.imgur.com/6XW6ewO.png" width="80%">
</div>

### Blocking Algorithm

处理data race最简单的方式是给程序**上锁(lock)**，这样可以保证同一时间只能有一个线程对指定的内存区域进行访问。锁之间的程序片断称为**critical section**，当某个线程执行critical section时其它需要访问同一内存的线程会被强制等待。

<div align=center>
<img src="https://i.imgur.com/j1n5Zax.png" width="80%">
</div>

尽管使用锁可以保证程序的正确执行，但锁的存在会影响程序的并行性。更严重的是它可能会产生**死锁(dead lock)**的现象从而阻塞程序的运行。因此在编写并行程序时需要注意尽可能减少锁的使用。

<div align=center>
<img src="https://i.imgur.com/h6rClgJ.png" width="80%">
</div>

### Atomic Operation

处理data race的另一种常用方法是使用**原子操作(atomic operation)**。原子操作是硬件层面实现的最基本操作，它无法同时被多个CPU一起执行。利用原子操作可以实现无锁的程序并行，从而极大地提升运行效率。

<div align=center>
<img src="https://i.imgur.com/DaOv4bG.png" width="80%">
<img src="https://i.imgur.com/UaGzzhG.png" width="80%">
</div>

### Complier Reordering Optimizations

另一方面需要注意的是现代编译器对于高级语言是可以进行自动优化的。这种优化可以提升单线程程序的运行效率，但对于多线程的情况则可能会导致一些问题。

<div align=center>
<img src="https://i.imgur.com/h6rClgJ.png" width="80%">
<img src="https://i.imgur.com/JBLswBA.png" width="80%">
</div>

实际上很多的现代芯片出于种种方面的考虑都无法保证多线程情况下编译后代码的执行顺序。

<div align=center>
<img src="https://i.imgur.com/pqU3uW8.png" width="80%">
</div>

## Parallel Framework of Game Engine

### Fixed Multi-Thread

游戏引擎在使用多线程时最经典的架构是**fixed multi-thread**，此时引擎中的每个系统都各自拥有一个线程。在每一帧开始时会通过线程间的通信来交换数据，然后各自执行自己的任务。

<div align=center>
<img src="https://i.imgur.com/ouQEYc2.png" width="80%">
</div>

fixed multi-thread的一个缺陷在于它很难保证不同线程上负载是一致的。实际上不同线程之间负载的差异往往非常巨大，很多时候一些线程已经完成了自己的任务却必须要等待其它线程结束。这就造成了计算资源的浪费。

<div align=center>
<img src="https://i.imgur.com/4QD7Os7.png" width="80%">
</div>

### Thread Fork-Join

另一种并行处理的方式是**fork-join**。对于某些负载比较高的系统我们可以实现申请一系列线程，当需要执行计算时通过fork操作把不同的计算任务分配到各个线程中并最后汇总到一起。

<div align=center>
<img src="https://i.imgur.com/mZimjhq.png" width="80%">
</div>

fork-join的缺陷在于有很多的任务是无法事先预测具体的负载的。

<div align=center>
<img src="https://i.imgur.com/sqNrEQU.png" width="80%">
</div>

在虚幻引擎中设计了name thread和worker thread两种类型的线程。其中name thread对应引擎中的不同系统，而worker thread则是系统中具体计算任务的线程。

<div align=center>
<img src="https://i.imgur.com/g92VyeU.png" width="80%">
</div>

### Task Graph

除此之外还可以使用**task graph**来处理多线程，task graph会根据不同任务之间的依赖性来决定具体的执行顺序以及需要进行并行的任务。

<div align=center>
<img src="https://i.imgur.com/R93aA32.png" width="80%">
<img src="https://i.imgur.com/9W9WcXV.png" width="80%">
</div>

## Job System

### Coroutine

**协程(coroutine)**是一种轻量的线程上下文切换机制，它允许函数在执行过程中临时切换到协程上然后再切换回来。和线程相比，协程无需硬件层面上的数据切换，可以由程序自己进行定义，也不需要进入系统内核执行interruption。因此协程要比线程切换高效的多。

<div align=center>
<img src="https://i.imgur.com/zYk2WG5.png" width="80%">
<img src="https://i.imgur.com/4K5bxSp.png" width="80%">
</div>

#### Stackful Coroutine

协程有两种实现方式。首先是使用栈来保存函数切换时的状态，当协程切换回来后根据栈上的数据来恢复之前的状态。

<div align=center>
<img src="https://i.imgur.com/o0mpzYa.png" width="80%">
</div>

#### Stackless Coroutine

另一种实现方式是不保存函数切换时的状态，当协程切换回来后按照当前的状态继续执行程序。

<div align=center>
<img src="https://i.imgur.com/o2xyE3l.png" width="80%">
</div>

在实践中一般推荐使用基于栈来实现的协程。尽管它在进行切换时的开销要稍微多一些，但可以避免状态改变导致的各种问题。

<div align=center>
<img src="https://i.imgur.com/0onKFv9.png" width="80%">
</div>

### Fiber-Based Job System

基于协程的思想可以实现**fiber-based job system**。在这种任务系统中job会通过fiber来进行执行，在线程进行计算时通过fiber的切换来减少线程调度的开销。

<div align=center>
<img src="https://i.imgur.com/RWfrZAo.png" width="80%">
</div>

对于多核的情况我们希望尽可能保证一个线程对应一个核(包括逻辑核)，这样可以进一步减少线程切换带来的额外开销。

<div align=center>
<img src="https://i.imgur.com/35O1kTr.png" width="80%">
</div>

在执行计算时根据程序的需要生成大量的job，然后调度器根据线程负载分配到合适的线程以及线程上的fiber中。

<div align=center>
<img src="https://i.imgur.com/uNQRZQH.png" width="80%">
<img src="https://i.imgur.com/paEmijU.png" width="80%">
</div>

在执行job时根据计算顺序可以分为FIFO以及LIFO两种模式，在实践工程中一般会选择LIF。

<div align=center>
<img src="https://i.imgur.com/Yqgz4Dj.png" width="80%">
</div>

当job出现依赖时会把当前的job移动到等待区然后执行线程中的下一个job。这样的方式可以减少CPU的等待，提高程序效率。

<div align=center>
<img src="https://i.imgur.com/7XJlq5G.png" width="80%">
</div>

如果出现了线程闲置的情况，调度器会把其他线程中的job移动到闲置线程中进行计算。

<div align=center>
<img src="https://i.imgur.com/X0OhYKv.png" width="80%">
</div>

和上面介绍过的多线程方法相比，任务系统可以更好地利用多核并且避免线程切换从而提升计算性能。不过目前原生C++暂不支持协程，而且在不同的操作系统中任务系统的实现往往是不同的。

<div align=center>
<img src="https://i.imgur.com/zUutz2a.png" width="80%">
</div>

## Programming Paradigms

## Data-Oriented Programming

## Performance-Sensitive Programming

## Performance-Sensitive Data Arrangements

## Entity Component System

## Reference

- [Lecture 20：Data-Oriented Programming and Job System (Part I)](https://www.bilibili.com/video/BV1EP411V7jx/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)
- [Lecture 20：Data-Oriented Programming and Job System (Part II)](https://www.bilibili.com/video/BV1Md4y1G7zp/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)