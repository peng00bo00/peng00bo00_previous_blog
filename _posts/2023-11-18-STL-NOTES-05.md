---
layout: article
title: C++ STL笔记05-std::list双向链表
tags: ["C++", "STL"]
key: STL-05
clipboard: true
aside:
  toc: true
sidebar:
  nav: STL
---

> 动手实现C++ STL容器。本节介绍std::list的常见用法和实现。
<!--more-->

## std::list用法

[std::list](https://en.cppreference.com/w/cpp/container/list)是C++标准库中的一个容器，它有如下特点：

- 双向链表结构：`std::list`使用双向链表实现，每个元素都包含指向前一个和后一个元素的指针，这使得在列表中间快速插入和删除元素的时间复杂度为`O(1)`。

- 非连续内存：与数组不同，`std::list`的元素在内存中不是连续存储的，因为每个元素包含指向前后元素的指针。这意味着在插入和删除操作时，不需要移动大量的元素，这有助于提高性能。

- 无随机访问：由于元素不是在连续内存中存储的，因此不能像数组一样通过索引进行`O(1)`的随机访问。在 `std::list`中，访问元素需要遍历链表，因此时间复杂度为`O(n)`。

- 动态大小：`std::list`的大小可以动态地增长或减小，不需要提前指定容器的大小。

- 高效的插入和删除操作：由于 `std::list`是双向链表，它对于在列表的任意位置执行插入和删除操作非常高效。这使得它在需要频繁插入和删除操作的场景中比较有优势。

- 相对较大的存储开销：由于每个元素都需要额外的指针来指向前一个和后一个元素，相较于数组，`std::list`在存储上会有一些额外的开销。

- 不支持随机访问迭代器：`std::list`提供双向迭代器，不支持随机访问迭代器。这与支持随机访问的容器(如 `std::vector`)不同。

`std::list`的一些常用用法如下：

```cpp
#include <iostream>
#include <list>

template <typename T>
void printList(std::list<T> &list) {
    // 遍历列表并输出元素
    for (T &x : list) {
        std::cout << x << " ";
    }
    
    std::cout << std::endl;
}

int main()
{
    // 创建一个存储整数的列表
    std::list<int> myList;

    // 在列表末尾插入元素
    std::cout << "Add to the back: ";
    
    myList.push_back(1);
    myList.push_back(2);
    myList.push_back(3);
    
    printList(myList);
    
    // 在列表开头插入元素
    std::cout << "Add to the front: ";
    
    myList.push_front(0);
    
    printList(myList);
    
    // 删除列表末尾的元素
    std::cout << "Remove the last element: ";
    
    myList.pop_back();
    
    printList(myList);
    
    // 删除列表开头的元素
    std::cout << "Remove the first element: ";
    
    myList.pop_front();
    
    printList(myList);
    
    // 在指定位置插入元素
    std::cout << "Insert to the 2nd position: ";
    
    auto it = myList.begin();
    ++it; // 移动到列表的第二个元素位置
    myList.insert(it, 4);
    
    printList(myList);

    // 在指定位置删除元素
    std::cout << "Remove the 2nd element: ";
    
    it = myList.begin();
    ++it; // 移动到列表的第二个元素位置
    myList.erase(it);
    
    printList(myList);
    
    // 获取列表大小
    std::cout << "Size of the list: " << myList.size() << std::endl;
    
    // 检查列表是否为空
    if (myList.empty()) {
        std::cout << "The list is empty." << std::endl;
    } else {
        std::cout << "The list is not empty." << std::endl;
    }
    
    // 清空列表
    std::cout << "Clear the list. " ;
    myList.clear();

    // 再次检查列表是否为空
    if (myList.empty()) {
        std::cout << "The list is empty." << std::endl;
    } else {
        std::cout << "The list is not empty." << std::endl;
    }

    return 0;
}
```
{: .snippet}

运行上面的代码可以得到如下结果：

```
Add to the back: 1 2 3 
Add to the front: 0 1 2 3 
Remove the last element: 0 1 2 
Remove the first element: 1 2 
Insert to the 2nd position: 1 4 2 
Remove the 2nd element: 1 2 
Size of the list: 2
The list is not empty.
Clear the list. The list is empty.
```

## List实现

接下来我们从零开始实现一个类似于标准库中`std::list`的双向链表`List`。

### 链表节点

在开始实现`List`之前我们需要先实现一下链表的节点，它通过`ListBaseNode`模板来实现：

```cpp
#ifdef NDEBUG
#define DEBUG_INIT_DEADBEAF(T)
#else
#define DEBUG_INIT_DEADBEAF(T) {(T *)0xdeadbeaf}
#endif

template <class T>
struct ListBaseNode {
    ListBaseNode *m_next DEBUG_INIT_DEADBEAF(ListBaseNode);
    ListBaseNode *m_prev DEBUG_INIT_DEADBEAF(ListBaseNode);

    inline T &value();
    inline T const &value() const;
};
```

`ListBaseNode`内部包含`m_next`以及`m_prev`两个指针，分别指向当前节点的前一个和后一个节点。这里引入了一个调试宏`DEBUG_INIT_DEADBEAF`：如果`NDEBUG`未被定义(即处于调试模式)，`DEBUG_INIT_DEADBEAF`会把指针成员初始化为一个特殊的值`0xdeadbeaf`以便发现和追踪可能出现的问题。

还需要注意的是这里定义的`ListBaseNode`本身是不包含任何数据的，我们通过一个继承自`ListBaseNode`的新类`ListValueNode`来表示一个携带数据的链表节点：

```cpp
template <class T>
struct ListValueNode : ListBaseNode<T> {
    union {
        T m_value;
    };
};

template <class T>
inline T &ListBaseNode<T>::value() {
    return static_cast<ListValueNode<T> &>(*this).m_value;
}

template <class T>
inline T const &ListBaseNode<T>::value() const {
    return static_cast<ListValueNode<T> const &>(*this).m_value;
}
```

当我们需要获取节点的数据时可以通过`value()`函数访问实际值所存储的`ListValueNode`类。此时函数会先把当前的`ListBaseNode<T>`转换为`ListValueNode<T>`类型的指针，然后访问`m_value`成员变量并返回所需的数据。

### 模板定义

`List`的模板定义类似于[Vector](/2023/11/12/STL-NOTES-04.html#模板定义)，都包含模板参数`T`和`Alloc`分别用来指定元素类型和管理内存。`List`本身则包含三个成员变量：

- `m_dummy`用来指向链表头
- `m_size`用来记录链表的大小
- `m_alloc`用来保存内存分配器

同时，这里还引入了两个类型别名`ListNode`和`AllocNode`。其中`AllocNode`将原本`T`类型的内存分配器重新绑定为`ListValueNode<T>`类型的内存分配器，这可以方便我们处理节点。

```cpp
template <class T, class Alloc = std::allocator<T>>
struct List {
private:
    using ListNode  = ListBaseNode<T>;
    using AllocNode = std::allocator_traits<Alloc>::template rebind_alloc<ListValueNode<T>>;

    ListNode m_dummy;
    size_t m_size;
    [[no_unique_address]] Alloc m_alloc;
}
```

为了方便添加和删除节点，这里还定义了两个辅助函数`newNode()`和`deleteNode()`进行处理：

```cpp
template <class T, class Alloc = std::allocator<T>>
struct List {
private:
    ListNode *newNode() {
        return AllocNode{m_alloc}.allocate(1);
    }

    void deleteNode(ListNode *node) noexcept {
        AllocNode{m_alloc}.deallocate(static_cast<ListValueNode<T> *>(node), 1);
    }
}
```

### 构造函数

#### 默认构造函数

`List`的默认构造函数用来处理无参数构造的情况。

```cpp
template <class T, class Alloc = std::allocator<T>>
struct List {
    ...
public:
    List() noexcept {
        m_size = 0;
        m_dummy.m_prev = m_dummy.m_next = &m_dummy;
    }
}
```

#### 参数化构造函数

#### 移动构造函数

#### 拷贝构造函数

### 访问元素

### 迭代器

### 其它函数

### 完整实现

## Reference

- [stl1weekend](https://github.com/parallel101/stl1weekend/tree/main#%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E6%89%80%E6%9C%89stl%E5%AE%B9%E5%99%A8)
- [【C++模板封装教学】自己动手实现循环双链表std::list，支持增删改查，迭代器双向遍历](https://www.bilibili.com/video/BV1SC4y1G7Ab/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)