---
layout: article
title: PBRT读书笔记09-Light Sources
tags: ["PBRT", "Rendering", "CG"]
key: PBRT-09
aside:
  toc: true
sidebar:
  nav: PBRT
---

> 这个系列是[Physically Based Rendering: From Theory To Implementation](https://pbr-book.org/)的读书笔记，本节主要介绍PBRT中的光源。
<!--more-->

为了渲染图像我们需要在场景中添加光源。PBRT中提供了不同类型光源的实现，本节会介绍常用光源中比较简单的几种类型。

## Light Emission

任何温度高于绝对零度的物体都包含运动的原子。根据Maxwell方程组，运动的原子会在一定的波长范围内向外发射电磁波。对于室温环境中的物体，其辐射大部分位于红外辐射的频率范围内；而如果想要达到可见光的范围则需要高得多的温度。

根据发光的物理过程，日常生活中常见的光源可以分为以下几种：

- 白炽灯(incandescent (tungsten) lamps)：通过电流加热灯丝实现发光，光线的频率分布与灯丝的温度有关。在发光过程中大部分的电能转换为了热能而不是光。
- 卤素灯(halogen lamps)：发光原理与白炽灯类似，但在灯泡中加入了卤素气体来延长灯丝的寿命。
- 气体放电灯(gas-discharge lamps)：在灯泡中充入气体各种气体和金属气体，通电后利用原子放电实现发光。
- LED灯：LED灯基于电致发光(electroluminescent)原理，当材料通电后会激发电子跃迁导致发光。

以上几种发光过程的本质都是电子和原子发生碰撞后外层电子会发生层级跃迁现象，当电子返回低能级时则会发射光子将能量释放。除了上面的几种发光过程，常见的发光过程还包括化学发光(chemoluminescence)和生物发光(bioluminescence)等。

我们定义**光视效能(luminous efficacy)**为光通量与辐射通量的比值，它表示光源将能量转换为可见光的效率：

$$
\frac{\int \Phi_e(\lambda) V(\lambda) \ d \lambda}{\int \Phi_i(\lambda) \ d \lambda}
$$

其中$V(\lambda)$为观测者在不同波长$\lambda$下的响应曲线。光视效能的单位是Watt，如果把分母部分定义为光源消耗的能量，则光视效能也描述了光源将能量转换为电磁辐射的效率。

### Blackbody Emitters

**黑体(blackbody)**是理想的辐射体，它会将能量尽可能高效地转换为电磁辐射。黑体的另一个特点是它会吸收所有的能量而不会发生任何反射行为，因此任何光照下黑体都是完美的黑色。**普朗克定律(Planck's law)**给出了黑体辐射与波长$\lambda$以及温度$T$之间的关系：

$$
L_e(\lambda, T) = \frac{2 h c^2}{\lambda^5 (e^{\frac{hc}{\lambda k_b T}} - 1)}
$$

其中$c$为光速，$h$为Planck常数，$k_b$为Boltzmann常数。不同温度下黑体在不同波长上的辐射曲线可参考下图：

<div align=center>
<img src="https://pbr-book.org/3ed-2018/Light_Sources/blackbody-L-vs-lambda.svg" width="55%">
</div>

在PBRT中使用`Blackbody()`函数计算黑体在指定温度和波长下的radiance：

```cpp
void Blackbody(const Float *lambda, int n, Float T, Float *Le) {
    const Float c = 299792458;
    const Float h = 6.62606957e-34;
    const Float kb= 1.3806488e-23;

    for (int i = 0; i < n; ++i) {
        // Compute emitted radiance for blackbody at wavelength lambda[i]
        Float l = lambda[i] * 1e-9;
        Float lambda5 = (l * l) * (l * l) * l;
        Le[i] = (2 * h * c * c) /
                (lambda5 * (std::exp((h * c) / (l * kb  * T)) - 1));
    }
}
```

根据**Stefan–Boltzmann定律(Stefan–Boltzmann law)**，黑体上任意一点$p$处的全频段辐出功率为：

$$
M(p) = \sigma T^4
$$

其中$\sigma$为Stefan–Boltzmann常数。

在很多情况下我们需要对黑体辐射进行规范化使得规范化后SPD的最大值为1，此时则需要使用**维恩位移定律(Wien's displacement law)**来计算黑体辐射在温度$T$下的峰值波长：

$$
\lambda_\text{max} = \frac{b}{T}
$$

其中$b$为维恩位移常数。在PBRT中使用`BlackbodyNormalized()`函数来计算规范化后的SPD：

```cpp
void BlackbodyNormalized(const Float *lambda, int n, Float T, Float *Le) {
    Blackbody(lambda, n, T, Le);

    // Normalize Le values based on maximum blackbody radiance
    Float lambdaMax = 2.8977721e-3 / T * 1e9;
    Float maxL;
    Blackbody(&lambdaMax, 1, T, &maxL);

    for (int i = 0; i < n; ++i)
        Le[i] /= maxL;
}
```

对于非黑体，其发射行为由**Kirchoff定律(Kirchoff’s law)**给出。Kirchoff定律说明对于达到热平衡的物体，它在任意温度和频率上发射的radiance等于理想黑体在同样状态下发射的radiance乘以物体吸收能量与入射能量的比例。由于物体吸收能量的比例与反射能量的比例之和为1，Kirchoff定律可以表示为：

$$
L'_e(T, \omega, \lambda) = L_e(T, \lambda) \ (1 - \rho_\text{hd}(\omega))
$$

其中$\rho_\text{hd}(\omega)$为**定向半球反射率(hemispherical-directional reflectance)**。

$$
\rho_\text{hd} (\omega_o) = \int_{H^2(\mathbf{n})} f_r(p, \omega_o, \omega_i) \vert \cos \theta_i \vert \ d \omega_i
$$

利用黑体辐射的SPD我们还可以定义**色温(color temperature)**。如果物体辐射的SPD与黑体在某一温度$T$下的SPD类似，则称物体的色温为$T$。在计算色温时的一种方法是首先计算光源发射SPD取最大时的波长，然后利用维恩位移定律计算出该波长对应黑体辐射的温度。

对于日常生活中常见的光源，白炽灯的色温一般在2,700K附近，卤素灯的色温在3,000 K附近，而荧光灯的色温则在2,700-6,500K范围上。通常情况下我们称色温高于5,000K的为冷色光，2,700–3,000K的为暖色光。

### Standard Illuminants

描述光源的另一种方法是使用CIE规定的**标准光源(standard illuminants)**。其中A类光源的SPD如下图所示，它相当于理想黑体2856K温度下的辐射，足以表示大部分白炽灯的行为。

<div align=center>
<img src="https://pbr-book.org/3ed-2018/Light_Sources/cie-a.svg" width="40%">
</div>

B类和C类光源用来表示一天中两个时间段的日照光，现已弃用。D类光源用来描述日照光的变化，它由一个固定项和两个可变项组成。两个可变项分别为云对应的黄-蓝颜色变化以及大气水分对应的粉-绿颜色变化。D65光源的SPD曲线可见下图，它的色温约为6504K对应欧洲正午时的日照。

<div align=center>
<img src="https://pbr-book.org/3ed-2018/Light_Sources/cie-d6500.svg" width="40%">
</div>

F型光源对应荧光，它们的曲线来自于对真实荧光光源的测量。

<div align=center>
<img src="https://pbr-book.org/3ed-2018/Light_Sources/cie-f4-f9.svg" width="50%">
</div>

## Light Interface

PBRT中使用`Light`类作为各种光源的通用接口，在进行初始化时需要提供4个参数：

- `flag`参数表示基础光源的类型，在积分时积分器会根据`flag`参数调整计算方法。
- `LightToWorld`参数定义了光源到世界坐标系的坐标变换。
- `mediumInterface`参数定义了光源位于的介质。
- `nSamples`参数定义了对光源进行采样时的样本数量。

`Light`类中比较重要的成员函数是`Light::Sample_Li()`，它用来计算没有遮挡情况下光源发出的光线到达$p$点时的radiance。对于一部分光源可能存在不止一条到达指定的的光路，此时`Light::Sample_Li()`函数会先在光源上随机采样然后再进行计算。

<div align=center>
<img src="https://pbr-book.org/3ed-2018/Light_Sources/Light%20Sample%20Li.svg" width="50%">
</div>

`Light::Power()`函数用来计算光源发出的总能量，这在某些光线传输算法中有着重要的作用。此外`Light`类还包含一个`Light::Preprocess()`函数用来对场景进行预处理。

`Light`类的完整定义如下：

```cpp
enum class LightFlags : int {
    DeltaPosition = 1, DeltaDirection = 2, Area = 4, Infinite = 8
};

inline bool IsDeltaLight(int flags) {
    return flags & (int)LightFlags::DeltaPosition ||
           flags & (int)LightFlags::DeltaDirection;
}

class Light {
public:
    virtual ~Light();
    Light(int flags, const Transform &LightToWorld,
          const MediumInterface &mediumInterface, int nSamples = 1)
        : flags(flags), nSamples(std::max(1, nSamples)),
          mediumInterface(mediumInterface), LightToWorld(LightToWorld),
          WorldToLight(Inverse(LightToWorld))  { 
        // Warn if light has transformation with non-uniform scale>
        if (WorldToLight.HasScale())
            Warning("Scaling detected in world to light transformation!\n"
                    "The system has numerous assumptions, implicit and explicit,\n"
                    "that this transform will have no scale factors in it.\n"
                    "Proceed at your own risk; your image may have errors or\n"
                    "the system may crash as a result of this.");
       }

    virtual Spectrum Sample_Li(const Interaction &ref, const Point2f &u, 
                     		   Vector3f *wi, Float *pdf, VisibilityTester *vis) const = 0;
    virtual Spectrum Power() const = 0;
    virtual void Preprocess(const Scene &scene) { }
    virtual Spectrum Le(const RayDifferential &r) const;
    virtual Float Pdf_Li(const Interaction &ref,  const Vector3f &wi) const = 0;
    virtual Spectrum Sample_Le(const Point2f &u1, const Point2f &u2,
                               Float time, Ray *ray, Normal3f *nLight,
                               Float *pdfPos, Float *pdfDir) const = 0;
    virtual void Pdf_Le(const Ray &ray, const Normal3f &nLight,
                        Float *pdfPos, Float *pdfDir) const = 0;

    const int flags;
    const int nSamples;
    const MediumInterface mediumInterface;

protected:
    const Transform LightToWorld, WorldToLight;
};
```

### Visibility Testing

`VisibilityTester`类用来测试两个点之间是否存在遮挡，它的基本定义如下：

```cpp
class VisibilityTester {
public:
    VisibilityTester(const Interaction &p0, const Interaction &p1)
        : p0(p0), p1(p1) { }
    const Interaction &P0() const { return p0; }
    const Interaction &P1() const { return p1; }
    bool Unoccluded(const Scene &scene) const;
    Spectrum Tr(const Scene &scene, Sampler &sampler) const;

private:
    Interaction p0, p1;
};
```

`VisibilityTester`类包含两种方法来判断可见性。首先是`VisibilityTester::Unoccluded()`函数，它会从`p0`向`p1`发射光线并利用场景是否与这条光线相交来判断可见性。

```cpp
bool VisibilityTester::Unoccluded(const Scene &scene) const {
    return !scene.IntersectP(p0.SpawnRayTo(p1));
}
```

如果需要考虑介质的散射行为则可以使用`VisibilityTester::Tr()`函数，它会考虑光线的透射率并返回光线衰减后剩余的比例。

```cpp
Spectrum VisibilityTester::Tr(const Scene &scene,
                              Sampler &sampler) const {
    Ray ray(p0.SpawnRayTo(p1));
    Spectrum Tr(1.f);
    while (true) {
        SurfaceInteraction isect;
        bool hitSurface = scene.Intersect(ray, &isect);
        // Handle opaque surface along ray’s path
        if (hitSurface && isect.primitive->GetMaterial() != nullptr)
            return Spectrum(0.0f);

        // Update transmittance for current ray segment
        if (ray.medium)
            Tr *= ray.medium->Tr(ray, sampler);

        // Generate next ray segment or return final transmittance
        if (!hitSurface)
            break;
        ray = isect.SpawnRayTo(p1);
    }

    return Tr;
}
```

## Point Lights

## Distant Lights

## Area Lights

## Infinite Area Lights

## Reference

- [12 Light Sources](https://pbr-book.org/3ed-2018/Light_Sources)