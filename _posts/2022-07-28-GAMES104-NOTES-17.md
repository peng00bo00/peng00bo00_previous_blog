---
layout: article
title: GAMES104课程笔记17-Advanced Artificial Intelligence
tags: ["GAMES104", "CG"]
key: GAMES104-17
aside:
  toc: true
sidebar:
  nav: GAMES104
---

> 这个系列是GAMES104-现代游戏引擎：从入门到实践([GAMES 104: Modern Game Engine-Theory and Practice](https://games104.boomingtech.com/en/))的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍游戏AI的高级技术。
<!--more-->

## Hierarchical Tasks Network

**层次任务网络(hierarchical tasks network, HTN)**是经典的游戏AI技术，和上一节介绍过的行为树相比HTN可以更好地表达AI自身的意志和驱动力。

<div align=center>
<img src="https://i.imgur.com/4I7FBkU.png" width="80%">
</div>

HTN的思想是把总体目标分解成若干个步骤，其中每个步骤可以包含不同的选项。AI在执行时需要按照顺序完成每个步骤，并且根据自身的状态选择合适的行为。

<div align=center>
<img src="https://i.imgur.com/WTmq3fH.png" width="80%">
</div>

### HTN Framework

HTN框架中包含两部分，**world state**和**sensor**两部分。其中world state是AI对于游戏世界的认知，而sensor则是AI从游戏世界获取信息的渠道。

<div align=center>
<img src="https://i.imgur.com/PzwkQex.png" width="80%">
</div>

除此之外HTN还包括**domain**，**planner**以及**plan runner**来表示AI的规划以及执行规划的过程。

<div align=center>
<img src="https://i.imgur.com/NIgzWmt.png" width="80%">
</div>

### HTN Task Types

在HTN中我们将任务分为两类，**primitive task**和**compound task**。

<div align=center>
<img src="https://i.imgur.com/WHd8iWK.png" width="80%">
</div>

primitive task一般表示一个具体的动作或行为。在HTN中每个primitive task需要包含precondition、action以及effects三个要素。

<div align=center>
<img src="https://i.imgur.com/8e2Rubm.png" width="80%">
<img src="https://i.imgur.com/7LbXg9S.png" width="80%">
</div>

而compound task则包含不同的方法，我们把这些方法按照一定的优先级组织起来并且在执行时按照优先级高到低的顺序进行选择。每个方法还可以包含其它的primitive task或者compound task，当方法内所有的task都执行完毕则表示任务完成。

<div align=center>
<img src="https://i.imgur.com/uyiZZfx.png" width="80%">
<img src="https://i.imgur.com/0AM4PCH.png" width="80%">
</div>

在此基础上就可以构造出整个HTN的domain，从而实现AI的行为逻辑。

<div align=center>
<img src="https://i.imgur.com/Jak3o9O.png" width="80%">
<img src="https://i.imgur.com/gpnKV0x.png" width="80%">
</div>

### Planning

接下来就可以进行规划了，我们从root task出发不断进行展开逐步完成每个任务。

<div align=center>
<img src="https://i.imgur.com/6wDGpPe.png" width="80%">
<img src="https://i.imgur.com/jGFZOQn.png" width="80%">
<img src="https://i.imgur.com/8e1rE9T.png" width="80%">
<img src="https://i.imgur.com/ZeuFXIu.png" width="80%">
<img src="https://i.imgur.com/CULPkyw.png" width="80%">
<img src="https://i.imgur.com/yjPOnj9.png" width="80%">
<img src="https://i.imgur.com/Kiq24df.png" width="80%">
</div>

### Replan

执行plan时需要注意有时任务会失败，这就需要我们重新进行规划，这一过程称为**replan**。

<div align=center>
<img src="https://i.imgur.com/l1qMknL.png" width="80%">
</div>

当plan执行完毕或是发生失败，亦或是world state发生改变后就需要进行replan。

<div align=center>
<img src="https://i.imgur.com/rFOzkJ1.png" width="80%">
</div>

总结一下HTN和BT非常相似，但它更加符合人的直觉也更易于设计师进行掌握。

<div align=center>
<img src="https://i.imgur.com/wzusHJq.png" width="80%">
</div>

## Goal-Oriented Action Planning

**goal-oriented action planning(GOAP)**是一种基于规划的AI技术，和前面介绍过的方法相比GOAP一般会更适合动态的环境。

<div align=center>
<img src="https://i.imgur.com/nJGp297.png" width="80%">
</div>

### Structure

GOAP的整体结构与HTN非常相似，不过在GOAP中domain被替换为**goal set**和**action set**。

<div align=center>
<img src="https://i.imgur.com/SEu8fOf.png" width="80%">
</div>

goal set表示AI所有可以达成的目标。在GOAP中需要显式地定义可以实现的目标，这要求我们把目标使用相应的状态来进行表达。

<div align=center>
<img src="https://i.imgur.com/qrFICyp.png" width="80%">
<img src="https://i.imgur.com/XnTavoj.png" width="80%">
</div>

而action set则接近于primitive task的概念，它表示AI可以执行的行为。需要注意的是action set还包含**代价(cost)**的概念，它表示不同动作的"优劣"程度。在进行规划时我们希望AI尽可能做出代价小的决策。

<div align=center>
<img src="https://i.imgur.com/o1RfZ08.png" width="80%">
</div>

### Planning

GOAP在进行规划时会从目标来倒推需要执行的动作，这一过程称为**反向规划(backward planning)**。

<div align=center>
<img src="https://i.imgur.com/CuHnqbo.png" width="80%">
</div>

在进行规划时首先需要根据优先级来选取一个目标，然后查询实现目标需要满足的状态。为了满足这些状态需求，我们需要从action set中选择一系列动作。需要注意的是很多动作也有自身的状态需求，因此我们在选择动作时也需要把这些需求添加到列表中。最后不断地添加动作和需求直到所有的状态需求都得到了满足，这样就完成了反向规划。

<div align=center>
<img src="https://i.imgur.com/HN9Qc2G.png" width="80%">
<img src="https://i.imgur.com/PyowWXA.png" width="80%">
<img src="https://i.imgur.com/gcBOPre.png" width="80%">
<img src="https://i.imgur.com/U5N6zrU.png" width="80%">
</div>

GOAP的难点在于如何从action set进行选择，我们要求状态需求都能够得到满足而且所添加动作的代价要尽可能小。显然这样的问题是一个**动态规划(dynamic programming)**问题，我们可以利用图这样的数据结构来进行求解。在构造图时把状态的组合作为图上的节点，不同节点之间的有向边表示可以执行的动作，边的权重则是动作的代价。这样整个规划问题就等价于在有向图上的最短路径问题。

<div align=center>
<img src="https://i.imgur.com/pwihLZo.png" width="80%">
<img src="https://i.imgur.com/gsJO3uj.png" width="80%">
</div>

总结一下GOAP可以让AI的行为更加动态，而且可以有效地解耦AI的目标与行为；而GOAP的主要缺陷在于它会比较消耗计算资源，一般情况下GOAP需要的计算量会远高于BT和HTN。

<div align=center>
<img src="https://i.imgur.com/ikCwkRc.png" width="80%">
</div>

## Monte Carlo Tree Search

## Machine Learning Basic

## Build Advanced Game AI

## Reference

- [Lecture 17：Advanced Artificial Intelligence (Part I)](https://www.bilibili.com/video/BV1iG4y1i78Q?spm_id_from=333.337.search-card.all.click&vd_source=7a2542c6c909b3ee1fab551277360826)
- [Lecture 17：Advanced Artificial Intelligence (Part II)](https://www.bilibili.com/video/BV1ja411U7zK/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)