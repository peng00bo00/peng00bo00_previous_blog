---
layout: article
title: GAMES104课程笔记19-Online Gaming Architecture Advanced Topics
tags: ["GAMES104", "CG"]
key: GAMES104-19
aside:
  toc: true
sidebar:
  nav: GAMES104
---

> 这个系列是GAMES104-现代游戏引擎：从入门到实践([GAMES 104: Modern Game Engine-Theory and Practice](https://games104.boomingtech.com/en/))的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍网络游戏架构的高级技术。
<!--more-->

## Character Movement Replication

**角色位移同步(character movement replication)**是现代大型网络游戏必须要实现的功能。由于网络环境的不稳定，玩家操作角色在自己视角和其他玩家视角下的行为往往会有一定的延迟，即角色在其他玩家视角下的动作会滞后于操作玩家的第一视角。

<div align=center>
<img src="https://i.imgur.com/tFMlMp2.png" width="80%">
</div>

### Interpolation & Extrapolation

在这种情况下我们可以使用**内插(interpolation)**和**外插(extrapolation)**两种插值方法来缓解延迟。

<div align=center>
<img src="https://i.imgur.com/yqZyoVf.png" width="80%">
</div>

#### Interpolation

内插是指利用已知的控制点来获得中间的状态。当网络存在波动时利用内插的方法可以保证角色的动作仍然是足够平滑的。

<div align=center>
<img src="https://i.imgur.com/CmimxUn.png" width="80%">
</div>

在具体进行插值时还可以人工设置一个offset来保证buffer中有足够多的控制点，这样虽然会提高一些延迟但可以获得更加光滑稳定的插值结果。

<div align=center>
<img src="https://i.imgur.com/4TztLxV.png" width="80%">
</div>

当然内插也存在一些问题。由于内插加剧了网络延迟的问题，同样的游戏世界在操作者和其他玩家的视角下会有非常大的差别。这样的问题在一些延迟要求很高的游戏中可能是不可接受的。

<div align=center>
<img src="https://i.imgur.com/fdKLO6w.png" width="80%">
</div>

#### Extrapolation

相比于内插，外插的本质是利用已有的信息来预测未来的状态。当我们对网络延迟有一定的估计时就可以通过外插的方法来推断角色的状态。

<div align=center>
<img src="https://i.imgur.com/616YGbl.png" width="80%">
</div>

实际上外插的思想在很多领域都有非常多的应用，dead reckoning算法那就是外插在导航领域的实践。

<div align=center>
<img src="https://i.imgur.com/XFPxN6h.png" width="80%">
</div>

### Projective Velocity Blending

回到游戏领域的应用中来，**projective velocity blending (PVB)**是一种使用外插来更新角色位置的算法。假设$t_0$时刻角色的位置、速度和加速度分别为$p_0$、$v_0$和$a_0$，而收到来自服务器同步的位置、速度和加速度则是$p_0'$、$v_0'$和$a_0'$。假设$t_0$到$t_B$时间内没有意外状况发生，则$t$时刻角色的位置为：

$$
p_t' = p_0' + v_0' t + \frac{1}{2} a_0' t^2
$$

我们的目的是通过调整速度使得角色可以在$t_B$时刻到达位置$p_d$，因此首先对速度进行插值：

$$
v_t = v_0 + \lambda (v_0' - v_0)
$$

$$
\lambda = \frac{t - t_0}{t_B - t_0}
$$

上式意味着对速度进行线性插值使得$t_B$时刻具有速度$v_0$。接下来再对位置进行线性插值即可：

$$
p_t = p_0 + v_t t + \frac{1}{2} a_0' t^2
$$

$$
p_d = p_t + \lambda (p_t' - p_t)
$$

<div align=center>
<img src="https://i.imgur.com/cfkbSI3.png" width="80%">
<img src="https://i.imgur.com/T2xxB3l.png" width="80%">
</div>

这里需要注意的是PVB算法并不符合动力学原理，它仅仅是一种插值方法。

### Collision Issues

外插在处理碰撞时会容易产生严重的物体穿插问题。

<div align=center>
<img src="https://i.imgur.com/cfkbSI3.png" width="80%">
<img src="https://i.imgur.com/FTNokpo.png" width="80%">
<img src="https://i.imgur.com/dnTfCgL.png" width="80%">
<img src="https://i.imgur.com/LjMsRPj.png" width="80%">
</div>

要处理这样的情况一般需要切换到本地物理引擎来处理碰撞问题，比如说在看门狗2中就使用了这样的方法。

<div align=center>
<img src="https://i.imgur.com/bLAd2fC.png" width="80%">
</div>

### Usage Scenarios

简单总结一下，对于玩家操作角色经常出现瞬移或是具有很大加速度的情况比较适合内插，对于操作角色比较符合物理规律的情况比较适合外插，而在一些大型在线游戏中还会同时结合这两种插值方法来提升玩家的游戏体验。

<div align=center>
<img src="https://i.imgur.com/b0y65Aj.png" width="80%">
<img src="https://i.imgur.com/DyzYnkN.png" width="80%">
<img src="https://i.imgur.com/lhECvgQ.png" width="80%">
</div>

## Hit Registration

## MMOG Network Architecture

## Bandwidth Optimization

## Anti-Cheat

## Build a Scalable World

## Reference

- [Lecture 19：Online Gaming Architecture Advanced Topics (Part I)](https://www.bilibili.com/video/BV13B4y1L7bZ?vd_source=7a2542c6c909b3ee1fab551277360826)
- [Lecture 19：Online Gaming Architecture Advanced Topics (Part II)](https://www.bilibili.com/video/BV1RG411t7TP/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)