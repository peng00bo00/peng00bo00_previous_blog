---
layout: article
title: GAMES104课程笔记19-Online Gaming Architecture Advanced Topics
tags: ["GAMES104", "CG"]
key: GAMES104-19
aside:
  toc: true
sidebar:
  nav: GAMES104
---

> 这个系列是GAMES104-现代游戏引擎：从入门到实践([GAMES 104: Modern Game Engine-Theory and Practice](https://games104.boomingtech.com/en/))的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍网络游戏架构的高级技术。
<!--more-->

## Character Movement Replication

**角色位移同步(character movement replication)**是现代大型网络游戏必须要实现的功能。由于网络环境的不稳定，玩家操作角色在自己视角和其他玩家视角下的行为往往会有一定的延迟，即角色在其他玩家视角下的动作会滞后于操作玩家的第一视角。

<div align=center>
<img src="https://i.imgur.com/tFMlMp2.png" width="80%">
</div>

### Interpolation & Extrapolation

在这种情况下我们可以使用**内插(interpolation)**和**外插(extrapolation)**两种插值方法来缓解延迟。

<div align=center>
<img src="https://i.imgur.com/yqZyoVf.png" width="80%">
</div>

#### Interpolation

内插是指利用已知的控制点来获得中间的状态。当网络存在波动时利用内插的方法可以保证角色的动作仍然是足够平滑的。

<div align=center>
<img src="https://i.imgur.com/CmimxUn.png" width="80%">
</div>

在具体进行插值时还可以人工设置一个offset来保证buffer中有足够多的控制点，这样虽然会提高一些延迟但可以获得更加光滑稳定的插值结果。

<div align=center>
<img src="https://i.imgur.com/4TztLxV.png" width="80%">
</div>

当然内插也存在一些问题。由于内插加剧了网络延迟的问题，同样的游戏世界在操作者和其他玩家的视角下会有非常大的差别。这样的问题在一些延迟要求很高的游戏中可能是不可接受的。

<div align=center>
<img src="https://i.imgur.com/fdKLO6w.png" width="80%">
</div>

#### Extrapolation

相比于内插，外插的本质是利用已有的信息来预测未来的状态。当我们对网络延迟有一定的估计时就可以通过外插的方法来推断角色的状态。

<div align=center>
<img src="https://i.imgur.com/616YGbl.png" width="80%">
</div>

实际上外插的思想在很多领域都有非常多的应用，dead reckoning算法那就是外插在导航领域的实践。

<div align=center>
<img src="https://i.imgur.com/XFPxN6h.png" width="80%">
</div>

### Projective Velocity Blending

回到游戏领域的应用中来，**projective velocity blending (PVB)**是一种使用外插来更新角色位置的算法。假设$t_0$时刻角色的位置、速度和加速度分别为$p_0$、$v_0$和$a_0$，而收到来自服务器同步的位置、速度和加速度则是$p_0'$、$v_0'$和$a_0'$。假设$t_0$到$t_B$时间内没有意外状况发生，则$t$时刻角色的位置为：

$$
p_t' = p_0' + v_0' t + \frac{1}{2} a_0' t^2
$$

我们的目的是通过调整速度使得角色可以在$t_B$时刻到达位置$p_d$，因此首先对速度进行插值：

$$
v_t = v_0 + \lambda (v_0' - v_0)
$$

$$
\lambda = \frac{t - t_0}{t_B - t_0}
$$

上式意味着对速度进行线性插值使得$t_B$时刻具有速度$v_0$。接下来再对位置进行线性插值即可：

$$
p_t = p_0 + v_t t + \frac{1}{2} a_0' t^2
$$

$$
p_d = p_t + \lambda (p_t' - p_t)
$$

<div align=center>
<img src="https://i.imgur.com/cfkbSI3.png" width="80%">
<img src="https://i.imgur.com/T2xxB3l.png" width="80%">
</div>

这里需要注意的是PVB算法并不符合动力学原理，它仅仅是一种插值方法。

### Collision Issues

外插在处理碰撞时会容易产生严重的物体穿插问题。

<div align=center>
<img src="https://i.imgur.com/cfkbSI3.png" width="80%">
<img src="https://i.imgur.com/FTNokpo.png" width="80%">
<img src="https://i.imgur.com/dnTfCgL.png" width="80%">
<img src="https://i.imgur.com/LjMsRPj.png" width="80%">
</div>

要处理这样的情况一般需要切换到本地物理引擎来处理碰撞问题，比如说在看门狗2中就使用了这样的方法。

<div align=center>
<img src="https://i.imgur.com/bLAd2fC.png" width="80%">
</div>

### Usage Scenarios

简单总结一下，对于玩家操作角色经常出现瞬移或是具有很大加速度的情况比较适合内插，对于操作角色比较符合物理规律的情况比较适合外插，而在一些大型在线游戏中还会同时结合这两种插值方法来提升玩家的游戏体验。

<div align=center>
<img src="https://i.imgur.com/b0y65Aj.png" width="80%">
<img src="https://i.imgur.com/DyzYnkN.png" width="80%">
<img src="https://i.imgur.com/lhECvgQ.png" width="80%">
</div>

## Hit Registration

**命中判定(hit registration)**同样是现代网络游戏必须要提供的基本服务。以FPS游戏为例，从玩家开枪到击中敌人这一过程实际上有着非常大的一段延迟，在各种不确定因素的影响下如何判断玩家确实击中目标就需要一些专门的设计。

<div align=center>
<img src="https://i.imgur.com/qC70S6X.png" width="80%">
</div>

### Challenges

命中判定的难点之一在于确定敌人在什么位置。由于网络延迟和插值算法的存在，玩家视角下的目标是落后于服务器上目标的真实位置的。

<div align=center>
<img src="https://i.imgur.com/eIXnga5.png" width="80%">
</div>

命中判定的另一个难点在于如何判定是否击中了目标。在游戏场景中目标往往是运动的，而且往往会位于一些掩体附近。当弹道不是瞬间命中时就需要一些额外的算法来进行判断。

<div align=center>
<img src="https://i.imgur.com/hIE2zD5.png" width="80%">
</div>

### Client-Side Hit Detection

因此命中判定的目标是保证游戏中的玩家就是否命中的问题能够达成一个**共识(consensus)**。目前主流的处理方法包括在客户端上进行检测，称为**client-side hit detection**，以及在服务器端进行判断的**server-side hit registration**。

<div align=center>
<img src="https://i.imgur.com/AgnAR2f.png" width="80%">
</div>

在客户端上进行检测时的基本思想是一切以玩家客户端视角下的结果为准。玩家开枪后的弹道轨迹以及击中判断都先在本地进行，然后发送到服务器上再进行验证。

<div align=center>
<img src="https://i.imgur.com/ovxyJWQ.png" width="80%">
<img src="https://i.imgur.com/ixhlK5h.png" width="80%">
</div>

在服务器上会对玩家的行为进行一些验证从而保证确实击中了目标。当然在实际的游戏中这个验证过程是相当复杂的，涉及到大量的验证和反作弊检测。

<div align=center>
<img src="https://i.imgur.com/kc5gU2I.png" width="80%">
</div>

在客户端上进行命中检测的优势在于它非常高效而且可以减轻服务器的负担，但它的核心问题在于它不够安全，一旦客户端被破解或是网络消息被劫持就需要非常复杂的反作弊系统来维持游戏平衡。

<div align=center>
<img src="https://i.imgur.com/tj85ODS.png" width="80%">
</div>

### Server-Side Hit Registration

在服务器端进行检测的一个难点在于服务器上角色的位置和状态是领先于玩家视角的，当玩家开枪时目标很可能已经移动到其它的位置上了。从这样的角度来看，玩家很难命中移动中的目标。

<div align=center>
<img src="https://i.imgur.com/0F8KuiO.png" width="80%">
</div>

因此我们需要对网络延迟进行一定的补偿。当服务器收到射击的消息时不会直接使用当前的游戏状态，而是根据延迟使用之前保存的游戏状态。

<div align=center>
<img src="https://i.imgur.com/vD6oP4t.png" width="80%">
<img src="https://i.imgur.com/i0eINIy.png" width="80%">
</div>

### Cover Problems

对于掩体的问题，由于网络延迟的存在可能会出现射击者优势或窥视者优势的情况。

<div align=center>
<img src="https://i.imgur.com/KNl7rGj.png" width="80%">
<img src="https://i.imgur.com/K7bWAn1.png" width="80%">
</div>

为了缓解延迟的问题在游戏设计时还可以利用动作**前摇(startup frames)**来掩盖掉网络同步。

<div align=center>
<img src="https://i.imgur.com/yVxbd4l.png" width="80%">
</div>

类似地，也可以使用各种特效来为服务器同步争取时间。

<div align=center>
<img src="https://i.imgur.com/h1nlMaE.png" width="80%">
</div>

## MMOG Network Architecture

## Bandwidth Optimization

## Anti-Cheat

## Build a Scalable World

## Reference

- [Lecture 19：Online Gaming Architecture Advanced Topics (Part I)](https://www.bilibili.com/video/BV13B4y1L7bZ?vd_source=7a2542c6c909b3ee1fab551277360826)
- [Lecture 19：Online Gaming Architecture Advanced Topics (Part II)](https://www.bilibili.com/video/BV1RG411t7TP/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)