---
layout: article
title: GAMES104课程笔记11-Applications in Physics System
tags: ["GAMES104", "CG"]
key: GAMES104-11
aside:
  toc: true
sidebar:
  nav: GAMES104
---

> 这个系列是GAMES104-现代游戏引擎：从入门到实践([GAMES 104: Modern Game Engine-Theory and Practice](https://games104.boomingtech.com/en/))的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍游戏引擎中物理系统的应用以及一些高级算法。
<!--more-->

## Character Controller

**角色控制器(character controller)**是玩家操作角色和游戏世界进行交互的接口。和很多人直观的认识不同，角色控制器在很多情况下实际上是一个非物理的。最常见的例子是玩家控制角色停止移动时角色会立即停住，而不是严格按照刚体仿真那样通过摩擦力来逐渐停止运动。某种意义上讲，角色控制器虽然是反物理的但却更符合人对物理世界的认知。

<div align=center>
<img src="https://i.imgur.com/x6NYW7E.png" width="80%">
<img src="https://i.imgur.com/wgAbEwW.png" width="80%">
</div>

### Build a Controller in Physics System

在构建角色控制器时一般会使用简化后的形状来包裹角色，这样便于处理各种场景之间的互动。

<div align=center>
<img src="https://i.imgur.com/KflUJE2.png" width="80%">
</div>

### Collide with Environment

在角色和场景进行互动时最常见的情况是玩家控制的角色撞到了墙壁上。如果严格按照物理引擎进行模拟，此时角色会一直停在碰撞的位置；而现代游戏中更常见的处理方式是修改角色的运动方向，使得角色可以沿墙壁方向进行滑动。

<div align=center>
<img src="https://i.imgur.com/WkqxvJj.png" width="80%">
</div>

### Auto Stepping

上下楼梯同样也是角色在场景中的一种常见行为。如果严格按照物理仿真进行处理，胶囊的上下楼梯会非常地困难。因此在游戏引擎中需要单独考虑这种情况，当角色上下楼梯时自动修正角色的位置。

<div align=center>
<img src="https://i.imgur.com/LpIReRH.png" width="80%">
</div>

对于斜坡这种情况，如果按照刚体运动学进行处理会导致角色下坡时直接从斜坡上滑下来，或是在上坡时由于具有过大的速度角色直接冲上它不应该到达的位置。为了避免这些问题需要单独考虑角色停在斜坡或是限制角色的位置。

<div align=center>
<img src="https://i.imgur.com/HD0H4EI.png" width="80%">
</div>

### Controller Volume Update

角色控制器还需要考虑角色体积发生变化的情况。当玩家控制角色进行下蹲等动作时需要自动更新角色控制体的体积，否则容易出现角色卡在门口无法进入的问题。

<div align=center>
<img src="https://i.imgur.com/i9mL6Br.png" width="80%">
</div>

### Controller Push Objects

当玩家控制角色和场景中的物体互动时需要对动态对象的运动状态加以更新。比较常见的处理方式是发生碰撞时对动态对象施加一个相应的冲量来控制它们的运动。

<div align=center>
<img src="https://i.imgur.com/HjTnDFv.png" width="80%">
</div>

### Standing on Moving Platform

除此之外，角色控制器还需要考虑动态场景的情况。当角色位于运动的平台时需要根据平台的运动来调整角色的运动状态，否则会出现平台发生运动时角色的运动没有同步或是滞后的问题。

<div align=center>
<img src="https://i.imgur.com/hORYId3.png" width="80%">
</div>

## Ragdoll

**布娃娃(ragdoll)**系统是游戏角色动画的一个重要组成部分，它最常见的例子是角色的处决动画：当玩家控制的角色处决了某个游戏对象时，根据处决场景的不同被处决对象会发生相应场景互动的动作。

<div align=center>
<img src="https://i.imgur.com/ed9j3XJ.png" width="80%">
</div>

### Map Skeleton to Rigid Bodies

实际上ragdoll与前面介绍过的[骨骼动画](/2022/05/11/GAMES104-NOTES-08.html#skinned-animation-implementation)密切相关。在模拟ragdoll的运动时，我们同样会在角色身上设置相应的节点并把不同节点之间的骨骼按照刚体进行模拟。不过出于实时计算上的考虑，ragdoll一般只会使用非常少量的节点和骨骼来进行模拟。

<div align=center>
<img src="https://i.imgur.com/G7rFn2k.png" width="80%">
</div>

### Human Joint Constraints

同样地，在ragdoll中需要考虑角色身上不同节点的运动是带有一定约束的。如果忽略了人体骨骼关节的约束则会导致非常扭曲的模拟效果。

<div align=center>
<img src="https://i.imgur.com/Ub9Higm.png" width="80%">
<img src="https://i.imgur.com/54bcEHK.png" width="80%">
</div>

一般来说ragdoll关节的约束会由TA进行设置，如果设置的不好会出现一些反直觉的动画效果。

<div align=center>
<img src="https://i.imgur.com/LJ9jkf7.png" width="80%">
<img src="https://i.imgur.com/VA9MPtd.png" width="80%">
</div>

### Animating Skeleton by Ragdoll

需要注意的是尽管我们可以使用ragdoll来模拟角色的动画，在实际游戏中仍然是需要通过骨骼关节系统来驱动整个角色的运动。由于ragdoll中的骨骼关节数量一般会少于实际角色的骨骼关节，我们需要使用[动画重定向](/2022/05/17/GAMES104-NOTES-09.html#animation-retargeting)技术来将ragdoll计算出的运动映射到实际的角色骨骼上。

<div align=center>
<img src="https://i.imgur.com/4cavCTn.png" width="80%">
</div>

### Blending between Animation and Ragdoll

在使用时还需要注意角色动画切换到ragdoll的过程。还是以角色处决动画为例，在一开始被处决对象是使用预先录制的角色动画，然后在某一时刻会切换成ragdoll使用物理系统来实时计算角色的行为。

<div align=center>
<img src="https://i.imgur.com/M1gOC3P.png" width="80%">
</div>

更进一步，在现代3A游戏中还会将角色动画和ragdoll实时计算出的动画进行混合来提升玩家的代入感和游戏体验。

<div align=center>
<img src="https://i.imgur.com/lW6B7z6.png" width="80%">
</div>

## Cloth

布料系统是游戏物理仿真中的重要一环。早期的布料模拟是使用预先录制的动画来实现的，我们可以在角色身上设置一些额外的骨骼来控制衣物的运动，这样就可以实现角色执行不同动作时衣物随之飘动的效果。

<div align=center>
<img src="https://i.imgur.com/a75lfeS.png" width="80%">
</div>

另一种处理衣物的方法是使用刚体运动的方法来模拟衣物和角色以及场景的互动。这样的处理方法虽然需要更多的计算资源，但可以实现相对真实衣物运动的效果。

<div align=center>
<img src="https://i.imgur.com/DVGIo03.png" width="80%">
</div>

### Mesh-Based Cloth Simulation

而在现代游戏引擎中衣物运动更多地是使用网格来进行模拟。这里首先要说明的是布料仿真中使用的网格是不同于渲染中所使用的网格，出于计算效率上的考虑布料仿真中使用的网格要比渲染中的网格要稀疏很多。

<div align=center>
<img src="https://i.imgur.com/yvcxpLE.png" width="80%">
</div>

同时在布料仿真中往往还会为网格上的每个顶点赋予一定位移的约束，从而获得更符合人直觉的仿真结果。

<div align=center>
<img src="https://i.imgur.com/Lpxqy0A.png" width="80%">
</div>

### Mass-Spring System

使用网格进行布料仿真的基本处理方法是使用质点弹簧系统进行模拟。我们为网格的顶点赋予一定的质量，然后将相邻顶点使用弹簧连接起来就形成了布料仿真的物理系统。这里需要注意的是除了弹簧弹力之外一般还需要为质点施加一定的阻尼来保证质点的运动最终能够停住。

<div align=center>
<img src="https://i.imgur.com/ILMJXu6.png" width="80%">
</div>

在放置弹簧时除了横竖方向外一般还需要在对角方向上也设置一些弹簧，这样可以保证布料具有抵抗对角方向的刚度。

<div align=center>
<img src="https://i.imgur.com/OUjIc7G.png" width="80%">
</div>

最后把外力施加在质点弹簧系统上就可以进行布料的运动仿真了。这里需要注意的是在进行仿真时不要忘记质点除了弹簧施加的弹力和阻尼外自身还会收到重力以及空气阻力的作用。

<div align=center>
<img src="https://i.imgur.com/fpiqBe9.png" width="80%">
</div>

### Verlet Integration

对质点弹簧系统进行仿真时不可避免地会使用到一些数值积分的方法，这里我们着重介绍一些Verlet积分算法。Verlet积分本质仍然是半隐式欧拉积分，不过在实际积分时可以将速度项约掉只保留位移和加速度项就能进行计算。因此Verlet积分不需要保存每一时刻的速度，我们只需要位移和力(加速度)就可以进行计算，从而提高布料仿真的效率。

<div align=center>
<img src="https://i.imgur.com/ciq7KUH.png" width="80%">
</div>

### Self Collision

布料仿真的一大难点在于如何处理**自相交(self collision)**问题。由于我们使用了没有体积的网格来表示布料，在进行仿真时很容易出现网格直接相互的穿插。

<div align=center>
<img src="https://i.imgur.com/CEGDBDD.png" width="80%">
</div>

目前布料自相交的问题还没有一个十分完善的解决方法。在工业界会使用一些trick来缓解自相交的问题，比如说对布料进行加厚、减少仿真时的时间步长、限制顶点的速度以及使用SDF进行控制等。

<div align=center>
<img src="https://i.imgur.com/cT2esCi.png" width="80%">
<img src="https://i.imgur.com/EdJTqyM.png" width="80%">
</div>

## Destruction

## Vehicle

## Advanced: PBD/XPBD

## Reference

- [Lecture 11：Physics System – Applications](https://www.bilibili.com/video/BV1Ya411j7ds/?spm_id_from=333.788)