---
layout: article
title: GAMES104课程笔记22-GPU-Driven Geometry Pipeline-Nanite
tags: ["CG", "GAMES104", "Game Engine"]
key: GAMES104-22
aside:
  toc: true
sidebar:
  nav: GAMES104
---

> 这个系列是GAMES104-现代游戏引擎：从入门到实践([GAMES 104: Modern Game Engine-Theory and Practice](https://games104.boomingtech.com/en/))的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍GPU驱动的几何管线与Nanite技术。
<!--more-->

## Introduction

### Traditional Rendering Pipeline

Nanite是虚幻5引擎中提出的虚拟几何系统用来实现渲染超高精度的网格。要理解Nanite首先要回顾一下经典渲染管线：当我们从CPU端发出渲染指令时会首先由CPU来准备各种渲染所需的资源，然后GPU会接收这些数据并计算实际的着色。这种模式的缺陷在于CPU可能无法跟上GPU的计算速度，而且CPU的算力会浪费在准备渲染素材这一过程中。

<div align=center>
<img src="https://i.imgur.com/rAwzzPc.png" width="80%">
</div>

随着渲染场景的复杂度逐渐提升，CPU端的计算开销会成为整个渲染过程的瓶颈。

<div align=center>
<img src="https://i.imgur.com/SBDI6x7.png" width="80%">
<img src="https://i.imgur.com/y1HYP0E.png" width="80%">
</div>

### Compute Shader

为了提升渲染效率人们开发出了**compute shader**这样的技术，其核心在于把过去只能在CPU端执行的通用计算转移的GPU端，从而节约掉大量的CPU到GPU端的通信开销。

<div align=center>
<img src="https://i.imgur.com/29Cc3Kd.png" width="80%">
</div>

### Graphics API

在图形API层面上过去只能一次绘制一个网格，而现代图形API则支持在一次DrawCall中同时绘制多个网格。

<div align=center>
<img src="https://i.imgur.com/5Kx1jQi.png" width="80%">
</div>

### GPU Driven Rendering Pipeline

总结一下，现代GPU驱动的渲染管线核心思想在于把CPU端的计算直接移动到GPU端，同时渲染所需的数据也会直接由GPU进行加载。在理想情况下CPU端只负责发出绘制指令，一切渲染数据加载和计算都在GPU端直接完成。

<div align=center>
<img src="https://i.imgur.com/JRByllG.png" width="80%">
</div>

## GPU Driven Pipeline in Assassins Creed

游戏工业对GPU驱动渲染管线的大规模应用可以追溯到《刺客信条：大革命》。在游戏中我们可以看到大量的拥有真实细节的建筑和场景，如何渲染这些极其复杂的几何对象是整个渲染管线的巨大挑战。

<div align=center>
<img src="https://i.imgur.com/Qhjqe2v.png" width="80%">
</div>

游戏开发团队提出了**mesh cluster rendering**的技术来提升渲染效率。mesh cluster rendering的思想在于对同一物体上的面片进行聚类，在渲染时首先根据cluster来判断面片的可见性

<div align=center>
<img src="https://i.imgur.com/YJCDc7C.png" width="80%">
</div>

整个游戏的渲染管线如下图所示。通过clustering的方法可以去除掉大量不可见的对象以及三角形，从而极大地缓解了GPU的渲染压力。

<div align=center>
<img src="https://i.imgur.com/WiPViGX.png" width="80%">
</div>

而在CPU端只负责非常少量的视锥剔除等工作，初步过滤掉不可见的物体。

<div align=center>
<img src="https://i.imgur.com/A3WLRd7.png" width="80%">
</div>

然后GPU端会把过滤后物体上的cluster拓展为chunk，每个instance可以属于不同的chunk而每个chunk可以包含不同的cluster。

<div align=center>
<img src="https://i.imgur.com/bAOPhdZ.png" width="80%">
</div>

GPU端进行实际的可见性剔除时会先检查chunk的可见性然后计算cluster的可见性。除了利用bounding box进行剔除外，还会同时结合三角形的朝向进行过滤，最后得到所有可见的三角形编号。

<div align=center>
<img src="https://i.imgur.com/2LVkUkv.png" width="80%">
</div>

所有可见三角形的编号会存储在一个事先申请的巨大buffer中。写入过程是原子化的，因此可以利用GPU并行计算来高效处理。而在进行渲染时可以利用这个buffer来并行处理所有的三角形，从而实现对场景的渲染。

<div align=center>
<img src="https://i.imgur.com/GPO6E5H.png" width="80%">
</div>

<div align=center>
<img src="https://i.imgur.com/4WIFxjq.png" width="80%">
</div>

## Occlusion Culling for Camera and Shadow

为了进一步提升渲染效率，除了剔除掉视野外的三角形外我们还希望能够把被遮挡住的三角形也同时剔除掉，这一过程称为**occlusion culling**。当相机在场景中的运动比较光滑时可以把前一帧的深度图投影到当前相机位置上，再结合hierarchy z-buffer就可以估计哪些cluster和三角形是可见的。

<div align=center>
<img src="https://i.imgur.com/ocIeFet.png" width="80%">
</div>

### Two-Phase Occlusion Culling

更现代的occlusion culling方法是使用上一帧和这一帧的两个z-buffer来实现。首先利用前一帧的z-buffer来快速选取可能可见的物体，然后使用这些物体来渲染新的z-buffer。显然此时的深度图会有非常多的洞等待填充，而且很多像素的深度可能是错误的。为了修正这个问题还需要再利用这一帧的深度图来测试前面过滤掉的其它物体。

<div align=center>
<img src="https://i.imgur.com/sZUdyeI.png" width="80%">
</div>

这种two-phase occlusion culling方法对于非常复杂的场景以及动态物体都有很好的性能。

<div align=center>
<img src="https://i.imgur.com/vda6izO.png" width="80%">
</div>

而对于阴影的问题也可以复用前一帧阴影的深度图并结合hierarchy z-buffer来进行剔除。

<div align=center>
<img src="https://i.imgur.com/y5ue2E6.png" width="80%">
</div>

要进一步提升阴影的渲染效率还可以结合相机的可见性，把所有相机方向不可见的物体全部剔除掉。

<div align=center>
<img src="https://i.imgur.com/sJYPHs2.png" width="80%">
<img src="https://i.imgur.com/cDuOqst.png" width="80%">
</div>

## Visibility Buffer

## Virtual Geometry - Nanite

### Overview

### Geometry Representation

### Rendering

### Virtual Shadow Map

### Streaming and Compression

## Reference

- [Lecture 22：GPU-Driven Geometry Pipeline-Nanite (Part I)](https://www.bilibili.com/video/BV1Et4y1P7ro/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)
- [Lecture 22：GPU-Driven Geometry Pipeline-Nanite (Part II)](https://www.bilibili.com/video/BV17G4y1x7VX/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)