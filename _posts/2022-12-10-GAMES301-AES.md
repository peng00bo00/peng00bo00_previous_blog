---
layout: article
title: Analytic Eigensystems for Isotropic Distortion Energies 论文笔记
tags: ["CG", "GAMES301", "Geometry Processing"]
key: GAMES301-16
aside:
  toc: true
sidebar:
  nav: GAMES301
---

> GAMES301-曲面参数化([GAMES 301: Surface Parameterization](http://staff.ustc.edu.cn/~renjiec/GAMES301/index.html))作业2解析与matlab实现。
<!--more-->

[*Analytic Eigensystems for Isotropic Distortion Energies*](http://www.tkim.graphics/EIGENSYSTEMS/AnalyticEigensystems.pdf)是来自Pixar动画工作室的一篇文章。这篇文章本身是用来处理变形体仿真的问题，主要贡献在于使用矩阵的不变量来描述变形能量并且推导了各向同性材料在相应能量下的解析解。除了物理仿真外，这种技术同样可以用来处理曲面参数化的问题。我们可以把初始状态的曲面想象成某种各项同性材料组成的表面，而参数化的过程相当于把这个表面展平并约束到平面上，此时曲面会通过释放变形能来降低自身的几何扭曲。这篇笔记会详细推导相关的理论并记录下我的matlab实现。

<div align=center>
<img src="https://i.imgur.com/IpAGdtr.png" width="80%">
</div>

## Background

### Deformation Gradient

三角形网格的变形可以使用一个线性函数来进行表示。具体来说，在平面上三角形的每一个顶点的位移都是其坐标的线性组合：

$$
\begin{bmatrix}
x \\ y
\end{bmatrix}
=
\begin{bmatrix}
F_{xx} & F_{xy} \\
F_{yx} & F_{xx} \\
\end{bmatrix}

\begin{bmatrix}
\bar{x} \\ \bar{y}
\end{bmatrix}
+
\begin{bmatrix}
t_x \\ t_y
\end{bmatrix}
$$

上式的矩阵形式为：

$$
\mathbf{x} = \mathbf{F} \mathbf{\bar{x}} + \mathbf{t}
$$

其中系数矩阵$\mathbf{F}$即为坐标变换的Jacobian矩阵，也称为**变形梯度(deformation gradient)**，它描述了三角形的旋转、缩放和反射；而向量$\mathbf{t}$则描述了三角形的刚体位移。

<div align=center>
<img src="https://i.imgur.com/dcpNCyD.png" width="50%">
<img src="https://i.imgur.com/XKFSSxL.png" width="50%">
</div>

变形梯度的计算非常简单，我们只需要考虑三角形两条对应边在变形前后的线性变换即可。我们可以以$\mathbf{\bar{x}}_0$作为三角形的局部原点，此时它的两条邻边分别为：

$$
\mathbf{\bar{o}}_1 = \mathbf{\bar{x}}_1 - \mathbf{\bar{x}}_0
$$

$$
\mathbf{\bar{o}}_2 = \mathbf{\bar{x}}_2 - \mathbf{\bar{x}}_0
$$

带入变形梯度$\mathbf{F}$可以得到：

$$
\mathbf{F}
\begin{bmatrix}
\mathbf{\bar{o}}_1 \vert \mathbf{\bar{o}}_2
\end{bmatrix}
=
\begin{bmatrix}
\mathbf{o}_1 \vert \mathbf{o}_2
\end{bmatrix}
$$

$$
\mathbf{F} \mathbf{D}_m = \mathbf{D}_s
$$

因此只需要求解矩阵方程即可：

$$
\mathbf{F} = \mathbf{D}_s \mathbf{D}_m^{-1}
$$

<div align=center>
<img src="https://i.imgur.com/Q59qOZm.png" width="80%">
</div>

计算三角形从初始构形x1到新构形x2的变形梯度(Jacobian矩阵)可以使用如下`findJacobian()`函数实现。

```matlab
function J = findJacobian(x1, x2)
%% Find Jacobian matrix from rest pose x1 to new pose x2
%% each row of x1/x2 is the coordinate of the triangle vertex

Dm = (x1(2:end, :) - x1(1, :))';
Ds = (x2(2:end, :) - x2(1, :))';

%% J * Dm = Ds
J = Ds * matrixInv2x2(Dm);

end
```

### Symmetric Dirichlet Energy

当三角形发生变形时会产生相应的变形能，此时就需要定义相应的能量函数。显然变形能量与三角形的刚体变换无关，因此它应该是只关于变形梯度$\mathbf{F}$的函数，而且与其中的旋转成分无关。这里可以使用**极分解(polar decomposition)**来分离出变形梯度中的旋转部分：

$$
\mathbf{F} = \mathbf{R} \mathbf{S}
$$

上式中矩阵$\mathbf{R}$即为变形梯度的旋转部分，称为**旋转梯度(rotation gradient)**；而矩阵$\mathbf{S}$则表示伸缩，称为**拉伸张量(stretch tensor)**。极分解的构造非常简单，我们只需要利用矩阵的**奇异值分解(singular value decomposition, SVD)**就可以实现：

$$
\mathbf{F} = \mathbf{U} \mathbf{\Sigma} \mathbf{V}^T
$$

$$
\mathbf{R} = \mathbf{U} \mathbf{V}^T
$$

$$
\mathbf{S} = \mathbf{V} \mathbf{\Sigma} \mathbf{V}^T
$$

容易验证如此定义的极分解满足所需的性质。不过需要注意的是直接利用SVD计算的旋转梯度$\mathbf{R}$可能会出现行列式为负的情况，而旋转矩阵一般要求其行列式为1。因此我们需要对标准的SVD进行一定的修改，保证$\mathbf{U}$和$\mathbf{V}$行列式同号：

```matlab
function [U, Sigma, V] = svd_rv(F)
%% rotation-variant SVD

%% standard SVD
[U, Sigma, V] = svd(F);

%% reflection matrix
%% modified for 2D deformation
L = eye(2,2);
L(2,2) = det(U * V');

%% see where to pull the reflection out of
detU = det(U);
detV = det(V);

if (detU < 0 && detV > 0)
    U = U * L;
elseif (detU > 0 && detV < 0)
    V = V * L;
end

%% push the reflection to the diagonal
Sigma = Sigma * L;

end
```

利用`svd_rv()`函数可以非常容易地定义极分解：

```matlab
function [R, S] = polarDecomposition(F)
%% polar decomposition with rotation-variant SVD

%% rotation variant SVD
[U, Sigma, V] = svd_rv(F);

R = U * V';
S = V * Sigma * V';

end
```

分理出旋转后就可以直接使用$\mathbf{S}$矩阵来定义变形能。**对称Dirichlet能量(symmetric Dirichlet energy)**是几何处理中非常流行的能量函数，它是由变形梯度的两个奇异值来定义的：

$$
\begin{aligned}
\Psi_\text{SD}
&= \frac{1}{2} \bigg( \sigma_1^2 + \sigma_2^2 + \frac{1}{\sigma_1^2} + \frac{1}{\sigma_2^2} \bigg) \\
&= \frac{1}{2} (\Vert \mathbf{F} \Vert_F^2 + \Vert \mathbf{F}^{-1} \Vert_F^2) \\
&= \frac{1}{2} (\Vert \mathbf{S} \Vert_F^2 + \Vert \mathbf{S}^{-1} \Vert_F^2)
\end{aligned}
$$

对称Dirichlet能量的特点在于它包含了奇异值的倒数，因此当三角形接近退化时会产生很大的能量作为惩罚项来避免进一步退化。计算对称Dirichlet能量$\Psi_\text{SD}$的代码如下：

```matlab
function E = computeSDEnergy(x1, x2)
%% Symmetric Dirichlet energy from x1 to x2

F = findJacobian(x1, x2);
Finv = matrixInv2x2(F);

E = norm(F, "fro")^2 + norm(Finv, "fro")^2;
E = 0.5*E;

end
```

而整个三角网格上我们一般会对每个三角形的变形能量按照它原来的面积进行加权：

$$
\Psi = \sum_q \vert q \vert \ \Psi_\text{SD} (\mathbf{F}_q)
$$

其中下标$q$表示每个单独的三角形。此时每个三角形的初始构型x1为单元自身定义的局部坐标系下的坐标，而构型x2则为参数平面上的uv坐标。计算整个网格上对称Dirichlet能量的matlab代码如下：

```matlab
function E = computeTotalSDEnergy(F, uv, X1, As)
%% Compute total symmetric Dirichlet energy of the mesh with current parameterization
nF = size(F, 1);
E  = 0;

for i=1:nF
    %% F[i, :] at local frame
    x1 = X1(:,:,i);
    q  = As(i);
    
    %% F[i, :] at uv plane
    x2= uv(F(i, :), :);

    Eq = computeSDEnergy(x1, x2);
    E = E + q*Eq;
end

end
```

### Projected Newton Method

变形体会通过最小化自身的变形能来恢复原始形状。从数学上来看这等价于一个最优化过程，因此我们可以通过求解一个最优化问题来计算变形。在几何处理中我们一般会使用二阶优化方法，和基于梯度的一阶方法相比二阶方法收敛更快而且无需手动设置优化步长。二阶方法中最经典的是**牛顿法(Newton's method)**，也称为**Newton-Raphson方法(Newton-Raphson method)**，对目标函数$f(\mathbf{x})$进行二阶近似有：

$$
f(\mathbf{x} + \mathbf{d}) \approx f(\mathbf{x}) + J^T(\mathbf{x}) \ \mathbf{d} + \frac{1}{2} \mathbf{d}^T H(\mathbf{x}) \ \mathbf{d}
$$

对上式右端按照$\mathbf{d}$进行求导并令导数为0可以得到：

$$
H(\mathbf{x}) \ \mathbf{d} = - J(\mathbf{x})
$$

当函数$f(\mathbf{x})$的Hessian矩阵非奇异时通过求解线性方程即可得到优化方向：

$$
\mathbf{d} = - H^{-1}(\mathbf{x}) \ J(\mathbf{x})
$$

因此对于参数化问题我们只需要计算对称Dirichlet能量$\Psi_\text{SD}$关于平面uv坐标的梯度与Hessian矩阵，然后利用牛顿法进行迭代即可，具体方法会在后面的小节进行详细的介绍。需要额外说明的是牛顿法的二阶收敛性需要保证目标函数的Hessian矩阵是正定矩阵，在很多情况下是无法直接保证的。因此我们会把Hessian矩阵投影到一个最近的正定矩阵上来进行处理，此时的优化算法称为**投影牛顿法(projected Newton method)**。

### Vec Operator

在计算导数时可能会遇到向量或是矩阵对矩阵求导的情况，此时得到的导数是一个高阶的**张量(tensor)**。高阶的张量非常不直观，因此这里介绍一下vec运算来将矩阵向量化。对于2×2的矩阵$\mathbf{A}$，vec运算将其转换为一个4维向量：

$$
\text{vec} (\mathbf{A}) = 
\text{vec} \bigg( 
\begin{bmatrix}
a & c \\ b & d
\end{bmatrix} 
\bigg)
=
\begin{bmatrix}
a \\ b \\ c \\ d
\end{bmatrix}
$$

vec运算的一大优势在于它与求导运算是可交换的，对张量求导再进行向量化等价于对向量化的张量进行求导。

$$
\text{vec} \bigg( \frac{\partial \mathbf{A}}{\partial x} \bigg) = \frac{\partial \ \text{vec} (\mathbf{A})}{\partial x}
$$

$$
\text{vec} \bigg( \frac{\partial A}{\partial \mathbf{x}} \bigg) = \frac{\partial A}{\partial \ \text{vec} (\mathbf{x})}
$$

这样利用vec进行向量化就可以把所有的张量运算转换为矩阵和向量的运算，使得推导和编程都更加清晰直观。

### Algorithm Framework

基于最小化变形能量的参数化算法框架如下：

1. 计算一个无翻转无重叠的参数化作为初始uv坐标，一般可由Tutte参数化来实现；
2. 计算变形能量关于当前uv坐标的梯度；
3. 计算变形能量关于当前uv坐标的Hessian矩阵，并投影到正定矩阵空间中；
4. 求解线性方程$H \mathbf{d} = -J$，得到uv坐标的更新方向；
5. 计算保证无翻转的更新步长，更新uv坐标；
6. 返回第2步进行迭代，直到梯度的模长足够小算法收敛。

整个算法框架和每一步的迭代分别封装在`projectedNewtonSolver()`以及`projectedNewtonStep()`两个函数中：

```matlab
function uv = projectedNewtonSolver(V, F, uv, maxSteps, maxIter, lam, c, gamma)
%% One step projected Newton solver
%% Args:
%%      V[nV, 3]: vertex coordinates in 3D
%%      F[nF, 3]: face connectivity
%%      uv[nV, 2]: vertex coordinates in 2D
%%      maxSteps: maximum steps in projected Newton
%%      maxIter: maximum iteration in line search
%%      lam: positive-definite parameter
%%      c: search control parameters
%%      gamma: shrinkage factor in line search
%% Returns:
%%      uv_new[nV, 2]: updated uv coordinates

nV = size(V, 1);
nF = size(F, 1);

%% reusable parameters
As    = zeros(nF, 1);          %% triangle area
X1    = zeros(3, 2, nF);    %% triangle at local frame
PfPxs = zeros(4, 6, nF);    %% PfPx at different triangles

for i=1:nF  
    x1 = project2Plane(V(F(i, :), :));

    As(i)        = Area(x1);
    X1(:,:,i)    = x1;
    PfPxs(:,:,i) = computePfPx(x1);
end

%% projected Newton step
for i=1:maxSteps
    fprintf('\nstep %d\n', i);
    
    [uv, stop] = projectedNewtonStep(V, F, uv, X1, As, PfPxs, maxIter, lam, c, gamma);
    
    if stop
        break
    end
end

end
```

```matlab
function [uv_new, stop] = projectedNewtonStep(V, F, uv, X1, As, PfPxs, maxIter, lam, c, gamma)
%% One step projected Newton update
%% Args:
%%      V[nV, 3]: vertex coordinates in 3D
%%      F[nF, 3]: face connectivity
%%      uv[nV, 2]: vertex coordinates in 2D
%%      X1[3, 2, nF]: vertex local coordinates
%%      As[nF, 1]: triangle areas
%%      PfPxs[4, 6, nF]: PfPx on different triangle
%%      maxIter: maximum iteration in line search
%%      lam: positive-definite parameter
%%      c: search control parameter
%%      gamma: shrinkage factor in line search
%% Returns:
%%      uv_new[nV, 2]: updated uv coordinates
%%      stop: stop iteration flag

nV = size(V, 1);
nF = size(F, 1);

stop = false;

%% gradient
b = computeGradient(V, F, uv, X1, As, PfPxs);
g = reshape(b, [nV, 2]);

%% early stop
if norm(b) < 1e-4
    uv_new = uv;
    stop = true;
    return
end

%% Hessian
H = projectHessian(V, F, uv, X1, As, PfPxs);
H = H + lam * speye(nV * 2);

%% solve the update direction
d = -H \ b;
d = reshape(d, [nV, 2]);

%% one step update
[uv_new, E, alpha] = lineSearch(V, F, uv, X1, As, PfPxs, d, g, maxIter, c, gamma);

fprintf("SD Energy: %.2e \tgradient: %.2e \talpha: %.2e\n", E, norm(b), alpha);

end
```

## Gradient

直接计算$\Psi$关于网格顶点uv坐标的导数往往是比较困难的，因此我们首先利用链式法则和变形梯度对导数进行分解：

$$
\begin{aligned}
\frac{\partial \Psi}{\partial \mathbf{x}} 
&= \sum_q \vert q \vert \ \frac{\partial}{\partial \mathbf{x}} \Psi_\text{SD} (\mathbf{F}_q) \\
&= \sum_q \vert q \vert \ {\frac{\partial \mathbf{f}_q}{\partial \mathbf{x}}}^T \frac{\partial \Psi_q}{\partial \mathbf{f}_q}
\end{aligned}
$$

注意这里$\mathbf{f}_q = \text{vec}(\mathbf{F}_q)$表示向量化后的变形梯度。根据上式我们只需要分别计算每个三角形上变形梯度关于uv坐标的导数$\frac{\partial \mathbf{f}}{\partial \mathbf{x}}$以及对称Dirichlet能量关于变形梯度的导数$\frac{\partial \Psi}{\partial \mathbf{f}}$两部分，再把它们乘起来按照初始构型的面积加权就得到了整体的梯度。

### Invariants

### $$\frac{\partial \mathbf{\Psi}}{\partial \mathbf{f}}$$

```matlab
function PphiPf = computePphiPf(F)
%% Compute partial derivative PphiPf of symmetric Dirichlet energy
%% Args:
%%      F[2, 2]: deformation graident
%% Returns:
%%      PphiPf[4, 1]: partial derivative

%% polar decomposition
[R, S] = polarDecomposition(F);

%% invariants
I1 = trace(S);
I2 = norm(S, "fro")^2;
I3 = det(S);

%% PPhiPI
PphiPI = [0; 0.5*(1+1/I3^2); -I2/I3^3];

%% PIPf
PIPf = zeros(4, 3);
PIPf(:, 1) = vec(R);
PIPf(:, 2) = 2*vec(F);

twist = [0, -1; 
         1,  0];
G = twist * F * twist';
PIPf(:, 3) = vec(G);

%% PphiPf
PphiPf = PIPf * PphiPI;

end
```

### $$\frac{\partial \mathbf{f}}{\partial \mathbf{x}}$$

```matlab
function uv = project2Plane(V)
%% Project a triangle to plane
%% Args:
%%      V[3, 3]: vertex coordinates in 3D, each row is a coordinate vector
%% Returns:
%%      uv[3, 2]: vertex coordinates in 2D

%% center in 3D
c = mean(V, 1);

%% normal
e1 = V(2, :) - V(1, :);
e2 = V(3, :) - V(1, :);
n = cross(e1, e2);
n = n / norm(n);

%% rotation
z = [0, 0, 1];
r = vrrotvec(n, z);

%% project to plane
uv = vrrotvec2mat(r) * (V - c)';
uv = uv(1:2, :)';

end
```

```matlab
function PfPx = computePfPx(x1)
%% Partial derivative of deformation gradient

Dm = (x1(2:end, :) - x1(1, :))';
DmInv = matrixInv2x2(Dm);
a = DmInv(1, 1); c = DmInv(1, 2);
b = DmInv(2, 1); d = DmInv(2, 2);

PfPx = zeros(4, 6);

%% hard coded PfPx
PfPx(1, 1) = -(a+b); PfPx(1, 2) =      0; PfPx(1, 3) = a; PfPx(1, 4) = 0; PfPx(1, 5) = b; PfPx(1, 6) = 0;
PfPx(2, 1) =      0; PfPx(2, 2) = -(a+b); PfPx(2, 3) = 0; PfPx(2, 4) = a; PfPx(2, 5) = 0; PfPx(2, 6) = b;
PfPx(3, 1) = -(c+d); PfPx(3, 2) =      0; PfPx(3, 3) = c; PfPx(3, 4) = 0; PfPx(3, 5) = d; PfPx(3, 6) = 0;
PfPx(4, 1) =      0; PfPx(4, 2) = -(c+d); PfPx(4, 3) = 0; PfPx(4, 4) = c; PfPx(4, 5) = 0; PfPx(4, 6) = d;

end
```

```matlab
function b = computeGradient(V, F, uv, X1, As, PfPxs)
%% gradient of symmetric Dirichlet energy
%% Args:
%%      V[nV, 3]: vertex coordinates in 3D
%%      F[nF, 3]: face connectivity
%%      uv[nV, 2]: vertex coordinates in 2D
%%      X1[3, 2, nF]: vertex local coordinates
%%      As[nF, 1]: triangle areas
%%      PfPxs[4, 6, nF]: PfPx on different triangle
%% Returns:
%%      b[nV*2, 1]: gradient of current parameterization

nV = size(V, 1);
nF = size(F, 1);

b = zeros(nV, 2);

%% loop over all the triangles
for i=1:nF
    %% F[i, :] at local frame
    x1 = X1(:,:,i);
    q  = As(i);

    %% F[i, :] at uv plane
    x2= uv(F(i, :), :);
    
    %% deformation gradient from local frame to uv plane
    f = findJacobian(x1, x2);
    
    %% partial derivative of phi
    PphiPf = computePphiPf(f);
    PfPx   = PfPxs(:,:,i);

    PphiPx = q * PfPx' * PphiPf;

    v1 = F(i, 1); v2 = F(i, 2); v3 = F(i, 3);
    b(v1, 1) = b(v1, 1) + PphiPx(1); b(v1, 2) = b(v1, 2) + PphiPx(2);
    b(v2, 1) = b(v2, 1) + PphiPx(3); b(v2, 2) = b(v2, 2) + PphiPx(4);
    b(v3, 1) = b(v3, 1) + PphiPx(5); b(v3, 2) = b(v3, 2) + PphiPx(6);
end

b = reshape(b, [nV*2, 1]);

end
```

## Hessian

### Analytic Eigen System

```matlab
function [eigs, lams] = SDEigenSystem(F)
%% Analytic eigensystem of symmetric Dirichlet energy
%% Args:
%%      F[2, 2]: deformation gradient
%% Returns:
%%      eigs[4]: eigen values
%%      lams[4, 4]: each row is an eigen vector

%% SVD
[R, S, U, Sigma, V] = polarSVD(F);

I1 = trace(S);
I2 = norm(S, "fro")^2;
I3 = det(S);

%% eigen values
eigs = zeros(4, 1);
eigs(1) = 1 + 3/Sigma(1,1)^4;
eigs(2) = 1 + 3/Sigma(2,2)^4;
eigs(3) = 1 + 1/I3^2 + I2/I3^3;
eigs(4) = 1 + 1/I3^2 - I2/I3^3;

%% eigen vectors
lams = zeros(4);

D1 = U * [1, 0; 0, 0] * V';
D2 = U * [0, 0; 0, 1] * V';
L  = U * [0, 1; 1, 0] * V' / sqrt(2);
T  = U * [0,-1; 1, 0] * V' / sqrt(2);

lams(:, 1) = vec(D1);
lams(:, 2) = vec(D2);
lams(:, 3) = vec(L);
lams(:, 4) = vec(T);

end
```

```matlab
function H = projectHessian(V, F, uv, X1, As, PfPxs)
%% Projected Hessian of symmetric Dirichlet energy
%% Args:
%%      V[nV, 3]: vertex coordinates in 3D
%%      F[nF, 3]: face connectivity
%%      uv[nV, 2]: vertex coordinates in 2D
%%      X1[3, 2, nF]: vertex local coordinates
%%      As[nF, 1]: triangle areas
%%      PfPxs[4, 6, nF]: PfPx on different triangle
%% Returns:
%%      H[nV*2, nV*2]: Hessian matrix of current parameterization

nV = size(V, 1);
nF = size(F, 1);

%% sparse matrix indices and values
I = zeros(nF*36, 1); J = zeros(nF*36, 1);
Value = zeros(nF*36, 1);

%% update with each triangle
for i=1:nF
    %% F[i, :] at local frame
    x1 = X1(:,:,i);
    q  = As(i);

    %% F[i, :] at uv plane
    x2= uv(F(i, :), :);
    
    %% deformation gradient from local frame to uv plane
    f = findJacobian(x1, x2);

    %% SVD
    [eigs, lams] = SDEigenSystem(f);
    eigs = max(eigs, 0);

    %% local Hessian
    Hq = lams * diag(eigs) * lams';

    %% PfPx
    PfPx   = PfPxs(:,:,i);
    Hq = q * PfPx' * Hq * PfPx;

    %% update indices and values
    v1x = F(i, 1); v2x = F(i, 2); v3x = F(i, 3);
    v1y = v1x+nV;  v2y = v2x+nV;  v3y = v3x+nV;

    indices = [v1x, v1y, v2x, v2y, v3x, v3y];
    idxI = zeros(6) + indices';
    idxJ = zeros(6) + indices;
    
    idx = (i-1)*36+1;   % starting index
    I(idx:idx+35)     = reshape(idxI, 1, []);
    J(idx:idx+35)     = reshape(idxJ, 1, []);
    Value(idx:idx+35) = reshape(Hq,   1, []);
end

H = sparse(I, J, Value, nV*2, nV*2);

end
```

## Line Search

## Results

## Reference

- [Analytic Eigensystems for Isotropic Distortion Energies](http://www.tkim.graphics/EIGENSYSTEMS/AnalyticEigensystems.pdf)
- [Analytic Eigensystems for Isotropic Distortion Energies Supplemental Material](http://www.tkim.graphics/EIGENSYSTEMS/AnalyticEigensystemsSupplement.pdf)
- [Dynamic Deformables: Implementation and Production Practicalities](https://www.tkim.graphics/DYNAMIC_DEFORMABLES/)