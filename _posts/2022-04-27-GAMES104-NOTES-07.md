---
layout: article
title: GAMES104课程笔记07-Render Pipeline, Post-process and Everything
tags: ["GAMES104", "CG"]
key: GAMES104-07
aside:
  toc: true
sidebar:
  nav: GAMES104
---

> 这个系列是GAMES104-现代游戏引擎：从入门到实践([GAMES 104: Modern Game Engine-Theory and Practice](https://games104.boomingtech.com/en/))的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍现代游戏引擎中的渲染管线以及其它常用的技术。
<!--more-->

## Ambient Occlusion

**环境光遮蔽(ambient occlusion, AO)**是现代游戏必备的渲染技术，通过AO可以获得更加丰富的光影变化以及更加立体的视觉感受。

<div align=center>
<img src="https://i.imgur.com/fgWRpwv.png" width="80%">
<img src="https://i.imgur.com/Lqb8MXU.png" width="80%">
</div>

从渲染方程的角度来看，AO的本质是计算网格上每个点在光照下的可见性。

<div align=center>
<img src="https://i.imgur.com/Bc9Fp0b.png" width="80%">
</div>

早期的AO是通过对网格进行预计算来实现，我们可以把顶点的可见性事先烘焙到网格信息中以便实际渲染时调用。这种方法目前在游戏工业中仍然有很多的应用。

<div align=center>
<img src="https://i.imgur.com/sAinfzq.png" width="80%">
</div>

### SSAO

显然这种AO方法只考虑的单个模型自身的几何信息，当把模型放置在场景中时是无法得到正确的AO效果的。为了克服这样的问题，人们提出了**SSAO**这种基于屏幕空间的AO算法。SSAO的处理方法是首先从相机出发渲染出一张深度图，然后对于深度图上的每一个像素我们在屏幕空间上找到该点对应的模型位置并在它的周围采样出$N$个点。利用这$N$个采样点以及深度图我们就可以估计该点处的遮挡关系，从而实现AO的效果。

<div align=center>
<img src="https://i.imgur.com/KzUvxuI.png" width="80%">
</div>

当然SSAO是一种近似方法，它本身是存在一些问题的。在SSAO的基础上人们又发展出了SSAO+算法，SSAO+没有在整个球体内进行采样而是根据顶点法向考虑法向对应的上半球上进行采样。这种改进克服了SSAO容易产生的整个游戏画面过暗的问题。

<div align=center>
<img src="https://i.imgur.com/WMTInR9.png" width="80%">
</div>

使用SSAO+实现的AO效果可见下图。SSAO相关方法的缺陷在于它只考虑了屏幕空间上的几何，这种简化在某些情况下会导致错误的结果。

<div align=center>
<img src="https://i.imgur.com/igPLdvy.png" width="80%">
<img src="https://i.imgur.com/BdM2lst.png" width="80%">
</div>

### HBAO

**HBAO**同样是基于屏幕空间的AO算法，它的思想是使用天顶角$\theta$的可见性来代替SSAO中的采样方法。我们可以通过对顶点法向上半球的方向通过ray marching的方式进行积分来估计它的可见性。

<div align=center>
<img src="https://i.imgur.com/ikaG0lR.png" width="80%">
<img src="https://i.imgur.com/O1ju9M4.png" width="80%">
</div>

### GTAO

上面介绍的几种算法都隐含地假设了顶点接收到来自不同方向上的光照是一致的，但实际上这种假设都没有考虑到渲染方程中的余弦项$\cos \theta$。**GTAO**补充了缺失的余弦项，此外对光线进行多次弹射的效果进行了拟合。

<div align=center>
<img src="https://i.imgur.com/BhAuMSY.png" width="80%">
<img src="https://i.imgur.com/1Pr7dlH.png" width="80%">
</div>

### Ray-Tracing Ambient Occlusion

当然，利用现代GPU的强大计算能力我们也可通过real time ray tracing的方式来计算AO。

<div align=center>
<img src="https://i.imgur.com/j6xbYJi.png" width="80%">
</div>

## Fog

### Depth Fog

雾效是游戏设计者非常喜欢的视觉效果。最简单的雾效是使用深度信息来考虑雾的视觉效果。

<div align=center>
<img src="https://i.imgur.com/hvzkrfl.png" width="80%">
</div>

### Height Fog

当然基于深度的雾效只有有限的表达效果。现实中的雾往往和它所处的高度有关，海拔高度越低的地方雾的效果越明显。对于这种视觉效果可以使用高度信息来进行近似：当高度大于一定的阈值时雾的效果会呈指数递减。

<div align=center>
<img src="https://i.imgur.com/B2rvZE6.png" width="80%">
</div>

### Voxel-based Volumetric Fog

在现代3A游戏中雾效可以使用体素化的方法来进行表现。在进行渲染时需要利用ray marching的方式考虑光线在参与介质中的各种行为，这样就可以获得逼真的雾效。

<div align=center>
<img src="https://i.imgur.com/Akl4nVm.png" width="80%">
</div>

## Anti-aliasing

**走样(aliasing)**是渲染中非常容易出现的问题。当相机的采样频率小于场景变化的频率时就会导致图像上出现各种各样的锯齿和走样。

<div align=center>
<img src="https://i.imgur.com/UVE3UiC.png" width="80%">
</div>

**反走样(anti-aliasing)**的目标是去除掉图像上的走样，它的基本思路是在每个像素点上进行多次采样并取平均，这样就可以过滤掉高频信号。

<div align=center>
<img src="https://i.imgur.com/PnlGGVE.png" width="80%">
</div>

### SSAA and MSAA

早期的反走样方法是直接使用更高的分辨率进行渲染，然后在输出图像前再通过降采样的方法来获得正常分辨率的图像，这样的方法称为**超采样(super sampling)**。显然超采样的方法会导致非常大的计算复杂度，在现代游戏引擎中基本已经弃用。类似地，**MSAA**则是在渲染时利用采样点进行着色然后通过取平均的方式来处理走样的问题。

<div align=center>
<img src="https://i.imgur.com/OT1fc7q.png" width="80%">
</div>

### FXAA

SSAA和MSAA的主要问题在于超采样的过程导致了巨大的计算复杂度，而**FXAA**则是直接在原始分辨率的图像上进行反走样。FXAA的思想是在图像的边缘区域使用插值的方式来实现反走样，因此FXAA首先需要使用边缘检测算子来检测出图像亮度发生剧烈变化的区域。

<div align=center>
<img src="https://i.imgur.com/Cgz4FWD.png" width="80%">
</div>

然后通过卷积运算，FXAA判断这些区域是在水平方向还是垂直方向发生了较大的变化并以此作为反走样补偿的方向。得到补偿方向后还需要根据相邻像素之间的亮度差值来选择亮度差异大的作为具体的方向。

<div align=center>
<img src="https://i.imgur.com/xwwwnMX.png" width="80%">
</div>

接下来FXAA会沿补偿方向的垂直方向寻找像素对，如果相邻像素在补偿方向上的差异与当前像素接近则与当前像素为同一组。通过向两边进行查找的方法来获得插值计算的端点。

<div align=center>
<img src="https://i.imgur.com/AjLIxdG.png" width="80%">
</div>

得到端点后可以根据当前点到两端的距离来确定插值的系数。

<div align=center>
<img src="https://i.imgur.com/YJ0Vlkb.png" width="80%">
</div>

最后对同一组中的像素进行颜色插值即可。

<div align=center>
<img src="https://i.imgur.com/5bPg1vh.png" width="80%">
</div>

FXAA的反走样效果如下：

<div align=center>
<img src="https://i.imgur.com/tOUV843.png" width="80%">
</div>

### TAA

除了上面介绍过的方法外另一种进行反走样的思路是利用时序信息进行反走样，这类方法称为**TAA**。TAA的思想是考虑每个像素在上一帧所处的位置，然后将上一帧对应位置的颜色和当前帧上的颜色进行加权平均来进行滤波。目前很多游戏引擎都使用了TAA相关的方法来实现反走样。

<div align=center>
<img src="https://i.imgur.com/aQJ5lsd.png" width="80%">
<img src="https://i.imgur.com/eid6iya.png" width="80%">
</div>

## Post-process

## Reference

- [Lecture 07：Render Pipeline, Post-process and Everything I](https://www.bilibili.com/video/BV1kY411P7QM/?spm_id_from=333.788)