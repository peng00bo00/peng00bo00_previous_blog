---
layout: article
title: GAMES104课程笔记04-Rendering on Game Engine
tags: ["GAMES104", "CG"]
key: GAMES104-04
aside:
  toc: true
sidebar:
  nav: GAMES104
---

> 这个系列是GAMES104-现代游戏引擎：从入门到实践([GAMES 104: Modern Game Engine-Theory and Practice](https://games104.boomingtech.com/en/))的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍现代游戏引擎的渲染系统。
<!--more-->

## Introduction

在接下来的几节课中我们会开始介绍游戏引擎中的渲染系统。从早期的像素风格渲染到如今3A大作逼真的渲染效果，可以说渲染技术伴随了整个游戏行业的发展。

<div align=center>
<img src="https://i.imgur.com/faYkxUg.png" width="80%">
</div>

游戏渲染的理论基础和图形学中的渲染是一样的。不过渲染研究更关注于算法理论的正确性而对于实时性没有太多的要求，而在游戏渲染中实时性则至关重要。对实时渲染的关注构成了游戏渲染和渲染理论之间的主要差别。

<div align=center>
<img src="https://i.imgur.com/yQqhMiE.png" width="80%">
</div>

### Challenges on Game Rendering

游戏中渲染的难点有以下几个方面：首先游戏场景往往包含各种不同类型的渲染对象，同时需要在场景中实现光照、大气、天空、水面等不同的渲染效果。

<div align=center>
<img src="https://i.imgur.com/N7dkyTe.png" width="80%">
</div>

其次，在图形学中我们不太关注渲染在硬件中的实现过程。而在游戏引擎中，为了充分利用计算资源则需要考虑渲染过程的硬件实现。

<div align=center>
<img src="https://i.imgur.com/iWW9Gii.png" width="80%">
</div>

再者，人们对于游戏画质和帧率的要求逐渐提高。现代3A大作往往需要适配4K的画幅并且保证不同场景下有着足够高的帧率(60-120FPS)。

<div align=center>
<img src="https://i.imgur.com/6X7QBVS.png" width="80%">
</div>

最后，游戏引擎除了渲染系统外还要为其它物理、逻辑系统提供支持，因此我们不能让渲染系统占掉全部的CPU计算资源。一般来说渲染系统只能占掉10-20%的计算资源，把省下来的资源让给其它玩法系统。

<div align=center>
<img src="https://i.imgur.com/fgdKxzM.png" width="80%">
</div>

### Rendering on Game Engine

总体来看，游戏引擎中的渲染系统是一个庞大的软件工程系统。在整个游戏行业几十年的不断实践中总结出了大量有效的渲染技术。

<div align=center>
<img src="https://i.imgur.com/QkwFtgX.png" width="80%">
</div>

本课程中我们会逐步介绍游戏引擎的渲染系统。当然游戏引擎涉及到的渲染技术非常丰富，这里只能介绍一些基础的概念。本节课会介绍渲染的基础概念，在后面的课程中会分别介绍游戏行业中标准的材质光照系统、场景渲染和后处理方法以及游戏引擎中的渲染管线设计。

<div align=center>
<img src="https://i.imgur.com/hfbyh65.png" width="80%">
</div>

本课程不会涉及卡通渲染、2D渲染引擎、次表面以及毛发渲染等内容。

<div align=center>
<img src="https://i.imgur.com/z2D7r6V.png" width="80%">
</div>

## Building Blocks of Rendering

### Rendering Pipeline and Data

目前游戏引擎渲染的主流方法仍是基于**光栅化(rasterization)**的渲染管线。

<div align=center>
<img src="https://i.imgur.com/ROIImSk.png" width="80%">
</div>

首先我们需要把场景中的物体投影到NDC上，然后分别计算平面上每一个像素对应的渲染对象。

<div align=center>
<img src="https://i.imgur.com/5l8t58c.png" width="80%">
</div>

接下来对于每一个像素需要调用相应的shader计算像素的颜色。

<div align=center>
<img src="https://i.imgur.com/A9ImQ1w.png" width="80%">
</div>

在调用shader时往往还需要通过纹理采样的方法进行反走样等处理。

<div align=center>
<img src="https://i.imgur.com/SDld6HF.png" width="80%">
</div>

### Understand the Hardware

渲染计算的特点是有大量的像素需要进行计算，而像素之间的计算则往往是相互独立的。因此人们设计出了GPU来执行图形渲染计算，这样还解放了CPU的计算资源。可以说现代GPU的发展也推动了整个游戏行业渲染技术的进步。

<div align=center>
<img src="https://i.imgur.com/T5jJnhi.png" width="80%">
</div>

要了解现代GPU的架构我们首先来复习一下SIMD和SIMT的概念。SIMD是指在运行程序时可以把一条指令同时执行在不同的数据上，目前现代CPU对于SIMD有着很好的支持，这种技术在高性能计算等领域中有着广泛的应用；而SIMT则是把同一条指令分配到大量的计算核心上同时执行，现代GPU的计算过程更类似于SIMT。

<div align=center>
<img src="https://i.imgur.com/7BmoOw8.png" width="80%">
</div>

在现代GPU架构中有着大量重复的内核，每一组内核称为一个GPC。在每个GPC内部存放着大量的SM，而每个SM中还有着大量的CUDA核心用来执行数学运算，当SM接收到指令进行计算时会把运算分配给CUDA核心进行并行计算。同时GPU上还有share memory用来实现GPU上不同核心以及GPU和CPU之间的通信。

<div align=center>
<img src="https://i.imgur.com/C0mucM7.png" width="80%">
</div>

GPU和CPU之间通信的代价是非常大的，因此在渲染系统中会尽量把数据通信设计为单向的。这样GPU只需要读取CPU发送的数据而无需反向传输渲染的结果。

<div align=center>
<img src="https://i.imgur.com/U9ydhNa.png" width="80%">
</div>

为了进一步提高数据读取的效率还需要合理地运用GPU缓存。

<div align=center>
<img src="https://i.imgur.com/YrqUYND.png" width="80%">
</div>

在长期的工程实践中人们总结了GPU渲染的性能瓶颈如下：

<div align=center>
<img src="https://i.imgur.com/hpnAddr.png" width="80%">
</div>

当然GPU的架构也是一个不断发展的领域，目前现代GPU架构已经可以支持更加灵活的渲染管线。

<div align=center>
<img src="https://i.imgur.com/BDXm3Zc.png" width="80%">
</div>

同时在不同的主机和设备上也往往有着不同于常见GPU的架构设计。

<div align=center>
<img src="https://i.imgur.com/8xuaGYp.png" width="80%">
<img src="https://i.imgur.com/Qzhu6Ge.png" width="80%">
</div>

## Renderable

## Render Objects in Engine

## Visibility Culling

## Texture Compression

## Authoring Tools of Modeling

## Cluster-Based Mesh Pipeline

## Reference

- [Lecture 04：Rendering on Game Engine](https://www.bilibili.com/video/BV14r4y1p7tt/?spm_id_from=333.788)