---
layout: article
title: Boundary First Flattening 论文笔记
tags: ["CG", "GAMES301", "Geometry Processing"]
key: GAMES301-18
clipboard: true
aside:
  toc: true
sidebar:
  nav: GAMES301
---

> GAMES301-曲面参数化([GAMES 301: Surface Parameterization](http://staff.ustc.edu.cn/~renjiec/GAMES301/index.html))作业4解析与matlab实现。
<!--more-->

[Boundary First Flattening(BFF)](http://www.cs.cmu.edu/~kmcrane/Projects/BoundaryFirstFlattening/paper.pdf)是基于共形映射的曲面参数化算法。和LSCM相比BFF允许用户控制参数平面上曲面的边界，因此非常适合纹理映射这样对网格边界有一定需求的任务。

## Background

BFF涉及到比较多的数学推导，因此在介绍具体的实现前我们首先来整理一下相关的数学知识。

### Confromal Maps

BFF的目标是计算一个流形到复平面的映射$f: \mathcal{M} \rightarrow \mathbb{C}$，当映射$f$能够保持切平面上向量的夹角时我们称这样的映射是一个**共形映射(confromal map)**。如果对于切平面上的任意向量$X$存在线性映射$\mathcal{J}$满足：

$$
df (\mathcal{J} X) = i \ df(X)
$$

则称$f$是一个**全纯映射(holomorphic map)**；其中$\mathcal{J}$称为$f$诱导的**共形结构(conformal structure)**，它相当于在切平面上将向量$X$逆时针旋转90°。实际上上式即为流形上的**Cauchy-Riemann方程(Cauchy-Riemann equation)**，如果$df$不会出现退化的情况则$f$一定是一个共形映射。

从度量的角度来看共形映射存在一个尺度缩放因子：

$$
e^u = \frac{\vert df(X) \vert}{\vert X \vert}
$$

$e^u$描述了切向量$X$在共形映射前后的缩放，且与$X$的方向无关；其中函数$u: \mathcal{M} \rightarrow \mathbb{R}$称为**对数共形因子(log conformal factor)**。

<div align=center>
<img src="https://i.imgur.com/4UFCPZN.png" width="60%">
</div>

### Conjugate Harmonic Function

共形映射的一个重要性质是它可以表示为一对**共轭调和函数(conjugate harmonic function)**。对于流形上的实值函数$a: \mathcal{M} \rightarrow \mathbb{R}$，当它满足Laplace方程时称其为调和函数：

$$
\Delta a = 0
$$

其中$\Delta$为**Laplace-Beltrami算子(Laplace-Beltrami operator)**。对于全纯映射$f=a+b \ i$，利用Cauchy-Riemann方程可以证明它的实部和虚部都满足Laplace方程：

$$
\Delta a = \nabla \cdot \nabla a = -\nabla \cdot (\mathcal{J} \nabla b) = 0
$$

$$
\Delta b = \nabla \cdot \nabla b = \nabla \cdot (\mathcal{J} \nabla a) = 0
$$

因此$f$的两个实值函数都是调和函数，称为一对共轭调和函数。

在离散网格上Laplace-Beltrami算子是一个矩阵$\mathbf{A} \in \mathbb{R}^{\vert V \vert \times \vert V \vert}$，其中每个元素满足：

$$
A_{ij} = 
\begin{cases}
-\frac{1}{2} (\cot \alpha_j + \cot \beta_j), & \text{for each edge $ij \in E$} \\
-\sum_{ij \in E} A_{ij}, & \text{for each vertex $i \in V$}
\end{cases}
$$

<div align=center>
<img src="https://i.imgur.com/l4rnQAN.png" width="50%">
</div>

具体的推导过程可以参考[前面的笔记](/2021/08/19/DDG-NOTES-3.html#discretization-via-dec)。Laplace-Beltrami算子的实现可以参考如下`cotLaplacian()`函数：

```matlab
function L = cotLaplacian(V, F)
%% Build (sparse) cotangent-Laplacian matrix
%% Args:
%%      V[nV, 3]: vertices in 3D
%%      F[nF, 3]: face connectivity
%% Returns:
%%      L[nV, nV]: sparse cotangent-Laplacian matrix

nV = size(V, 1);

%% edges
Es = reshape(V(F(:, [2, 3, 1]), :) - V(F, :), [size(F), 3]);

%% trigonometry
coss =-dot(Es(:, [2, 3, 1], :), Es(:, [3, 1, 2], :), 3);
sins = vecnorm(cross(Es(:, [2, 3, 1], :), Es(:, [3, 1, 2], :), 3), 2, 3);
cots = coss ./ sins;

%% cotangent-Laplacian adjacency
L = sparse(F, F(:, [2, 3, 1]), cots, nV, nV);
L = 0.5*(L + L');

%% L = D - A
L = diag(sparse(sum(L, 1))) - L;

end
```
{: .snippet}


### Poisson Equation

除了Laplace方程外，BFF还涉及到在网格上求解**Poisson方程(Poisson equation)**：

$$
\Delta a = \phi
$$

其中$a$和$\phi$都是在网格上定义的实值函数。Poisson方程的解依赖于边界条件，当我们规定了$a$在边界上的函数值时称为**Dirichlet边界(Dirichlet condition)**：

$$
\begin{cases}
\Delta a = \phi, & \text{on \ $\mathcal{M}$} \\
a = g, & \text{on \ $\partial\mathcal{M}$} \\
\end{cases}
$$

而如果规定了$a$在边界上的梯度则称为**Neumann边界(Neumann condition)**：

$$
\begin{cases}
\Delta a = \phi, & \text{on \ $\mathcal{M}$} \\
\frac{\partial a}{\partial n} = h, & \text{on \ $\partial\mathcal{M}$} \\
\end{cases}
$$

在求解Poisson方程时可以通过在顶点dual cell上积分的方式来获得一系列线性方程组。我们将网格顶点分为内部顶点$\mathbf{I}$和边界顶点$\mathbf{B}$两部分，整理后可以得到：

$$
\begin{bmatrix}
\mathbf{A}_\mathbf{II} & \mathbf{A}_\mathbf{IB} \\
\mathbf{A}_\mathbf{BI} & \mathbf{A}_\mathbf{BB} \\
\end{bmatrix}

\begin{bmatrix}
a_\mathbf{I} \\ a_\mathbf{B} \\
\end{bmatrix}
=
\begin{bmatrix}
\phi_{\mathbf{I}} \\ \phi_{\mathbf{B}} \\
\end{bmatrix}
$$

需要说明的是线性系统的右端$\phi$项并不是函数在顶点上的值，而是它在顶点dual cell上的积分。

对于Dirichlet边界相当于已知$a_\mathbf{B} = g \in \mathbb{R}^{\vert \mathbf{B} \vert}$，因此只需要带入第一行进行求解即可：

$$
\mathbf{A}_\mathbf{II} \ a_\mathbf{I} = \phi_{\mathbf{I}} - \mathbf{A}_\mathbf{IB} \ g
$$

而对于Neumann边界则需要对梯度在边界上进行积分，此时线性方程组转换为：

$$
\begin{bmatrix}
\mathbf{A}_\mathbf{II} & \mathbf{A}_\mathbf{IB} \\
\mathbf{A}_\mathbf{BI} & \mathbf{A}_\mathbf{BB} \\
\end{bmatrix}

\begin{bmatrix}
a_\mathbf{I} \\ a_\mathbf{B} \\
\end{bmatrix}
=
\begin{bmatrix}
\phi_{\mathbf{I}} \\ \phi_{\mathbf{B}} - \mathbf{h} \\
\end{bmatrix}
$$

上式中$\mathbf{h} \in \mathbb{R}^{\vert \mathbf{B} \vert}$称为**discrete Neuman boundary data**。Neumann边界条件下线性系统的推导过程可以参考[前面的笔记](/2021/08/19/DDG-NOTES-3.html#boundary-conditions)。

### Yamabe Equation

```matlab
function [K, kappa] = discreteCurvature(V, F, B)
%% Compute discrete Gaussian and geodesic curvature
%% Args:
%%      V[nV, 3]: vertices in 3D
%%      F[nF, 3]: face connectivity
%%      B[1, nB]: boundary vertex index
%% Returns:
%%      K[nV, 1]: discrete Gaussian curvature
%%      kappa[nB, 1]: discrete geodesic curvature at the boundary

nV = size(V, 1);
nF = size(F, 1);

%% edges
Es    = reshape(V(F(:, [2, 3, 1]), :) - V(F, :), [size(F), 3]);
Enorm = vecnorm(Es, 2, 3);
Edir  = Es ./ Enorm;

%% interior angles
coss   =-dot(Edir(:, :, :), Edir(:, [3, 1, 2], :), 3);
angles = acos(coss);

%% sum over vertices
A = sparse(repmat((1:nF)', 1, 3), F, angles, nF, nV);
angles = full(sum(A, 1))';

%% discrete curvatures
K     = 2*pi - angles;
kappa = pi - angles(B);

%% set K=0 at the boundary
K(B) = 0;

end
```
{: .snippet}

### Poincaré-Steklov Operators

#### Dirichlet to Neumann

#### Neumann to Dirichlet

### Curve Integration

<div align=center>
<img src="https://i.imgur.com/wSzs5Jc.png" width="60%">
</div>

```matlab
function gamma = bestFitCurve(L, Ltarget, k)
%% Find the best fitted curve with given length and exterior angles
%% Args:
%%      L[nB, 1]: length of original curve segment
%%      Ltarget[nB, 1]: length of target curve segment
%%      k[nB, 1]: exterior angle of target curve segment
%% Returns:
%%      gamma[nB, 2]: fitted curve vertex

%% accumulate exterior angles and tangent vectors
phi = cumsum(k) - k(1);
T = [cos(phi) sin(phi)]';

%% boundary mass matrix
l = 0.5*(L + circshift(L, 1));     %% dual length
Ninv = diag(l);

%% solve optimal length to close the curve
TNTinv = matrixInv2x2(T * Ninv * T');
L = Ltarget - Ninv*T'*TNTinv*T*Ltarget;

%% accumulate scaled tangents
gamma = cumsum(L .* T', 1);
gamma = circshift(gamma, 1, 1);
gamma(1,:) = [0 0];

end
```
{: .snippet}

## Implementation

<div align=center>
<img src="https://i.imgur.com/TXJzQej.png" width="100%">
</div>

### BFF with Given Exterior Angles

```matlab
function uv = BFFAngle(V, F, k)
%% Boundary First Flattening with given exterior angles
%% Args:
%%      V[nV, 3]: vertices in 3D
%%      F[nF, 3]: face connectivity
%%      k[nB, 1]: target curvature at the boundary
%% Returns:
%%      uv[nV, 2]: uv coordinates

%% find boundary
[B, ~] = findBoundary(V, F);

nV = size(V, 1);

%% build Laplacian matrix
A = cotLaplacian(V, F);
A = A + 1e-8*speye(nV);

%% seperatate interior and boundary vertex
I = setdiff(1:nV, B);

AII = A(I,I);
AIB = A(I,B);
ABB = A(B,B);

%% discrete curvatures
[K, kappa] = discreteCurvature(V, F, B);

%% solve Yamabe equation (Neumann to Dirichlet)
phi = -K;
h = kappa - k;      %% Neumann data
phi(B) = phi(B) - h;

u = A \ phi;
u = u-mean(u);      %% constant offset

%% solve boundary curve length
uB = u(B); 
uBr= circshift(uB, -1); Br = circshift(B, -1);     %% left shift the array to find right endpoint
L  = vecnorm(V(B,:)-V(Br,:), 2, 2);
Ltarget  = exp((uB+uBr)/2) .* L;

%% best fit curve
gamma = bestFitCurve(L, Ltarget, k);

%% extend curve
uv = zeros(nV, 2);
uv(B, 1) = gamma(:, 1);
uv(I, 1) = AII \ (-AIB*gamma(:, 1));

%% Hilbert transform
aB = uv(B, 1); h = zeros(nV, 1);
h(B, :) =-0.5*(circshift(aB, -1) - circshift(aB, 1));
uv(:, 2) = A \ h;

uv = uv - mean(uv, 1);

end
```
{: .snippet}

### BFF with Given Scaling Factors

```matlab
function uv = BFFScale(V, F, u)
%% Boundary First Flattening with given scale factors
%% Args:
%%      V[nV, 3]: vertices in 3D
%%      F[nF, 3]: face connectivity
%%      u[nB, 1]: target scale factor at the boundary
%% Returns:
%%      uv[nV, 2]: uv coordinates

nV = size(V, 1);

%% find boundary
[B, ~] = findBoundary(V, F);

%% build Laplacian matrix
A = cotLaplacian(V, F);
A = A + 1e-8*speye(nV);

%% seperatate interior and boundary vertex
I = setdiff(1:nV, B);

AII = A(I,I);
AIB = A(I,B);
ABB = A(B,B);

%% discrete curvatures
[K, kappa] = discreteCurvature(V, F, B);

%% solve Yamabe equation (Dirichlet to Neumann)
phi =-K;
a = AII \ (phi(I)-AIB*u);
k = kappa - (phi(B) - AIB'*a - ABB*u);
k = k / sum(k) * 2 * pi;

%% solve boundary curve length
uB = u;
uBr = circshift(uB, -1); Br = circshift(B, -1);     %% left shift the array to find right endpoint
L  = vecnorm(V(B,:)-V(Br,:), 2, 2);
Ltarget  = exp((uB+uBr)/2) .* L;

%% best fit curve
gamma = bestFitCurve(L, Ltarget, k);

%% extend curve
uv = zeros(nV, 2);
uv(B, 1) = gamma(:, 1);
uv(I, 1) = AII \ (-AIB*gamma(:, 1));

%% Hilbert transform
aB = uv(B, 1); h = zeros(nV, 1);
h(B, :) =-0.5*(circshift(aB, -1) - circshift(aB, 1));
uv(:, 2) = A \ h;

uv = uv - mean(uv, 1);

end
```
{: .snippet}

### Applications

#### Automatic Parameterization

```matlab
function uv = BFFAuto(V, F)
%% Automatic parameterization with free boundary
%% Args:
%%      V[nV, 3]: vertices in 3D
%%      F[nF, 3]: face connectivity
%% Returns:
%%      uv[nV, 2]: uv coordinates

%% find boundary
[B, ~] = findBoundary(V, F);

u = zeros(length(B), 1);
uv = BFFScale(V, F, u);

end
```
{: .snippet}

#### Uniformization

```matlab
function uv = BFFUniform(V, F)
%% Uniformization to a disk with BFF
%% Args:
%%      V[nV, 3]: vertices in 3D
%%      F[nF, 3]: face connectivity
%% Returns:
%%      uv[nV, 2]: uv coordinates

%% find boundary
[B, ~] = findBoundary(V, F);

nV = size(V, 1);
Br = circshift(B, -1);

for i=1:10
    %% dual edge length
    L = vecnorm(V(B,:)-V(Br,:), 2, 2);
    l = 0.5*(L + circshift(L, 1));

    %% set exterior angle proportional to the most recent dual lengths
    k = l / sum(l) * 2 * pi;
    
    uv = BFFAngle(V, F, k);
    V = [uv zeros(nV, 1)];
end

uv = uv(:, 1:2);

end
```
{: .snippet}

#### Flatten to Square

```matlab
function uv = BFFSquare(V, F)
%% Uniformization to a square with BFF
%% Args:
%%      V[nV, 3]: vertices in 3D
%%      F[nF, 3]: face connectivity
%% Returns:
%%      uv[nV, 2]: uv coordinates

nV = size(V, 1);

%% find boundary
[B, ~] = findBoundary(V, F);

%% fix boundary exterior angle
nB= length(B);
k = zeros(nB,1);
k(floor((1:4)*nB/4)) = 2*pi/4;

%% build Laplacian matrix
A = cotLaplacian(V, F);
A = A + 1e-8*speye(nV);

%% seperatate interior and boundary vertex
I = setdiff(1:nV, B);

AII = A(I,I);
AIB = A(I,B);
ABB = A(B,B);

%% discrete curvatures
[K, kappa] = discreteCurvature(V, F, B);

%% solve Yamabe equation (Neumann to Dirichlet)
phi = -K;
h = kappa - k;      %% Neumann data
phi(B) = phi(B) - h;

u = A \ phi;
u = u-mean(u);      %% constant offset

%% solve boundary curve length
uB = u(B); 
uBr= circshift(uB, -1); Br = circshift(B, -1);     %% left shift the array to find right endpoint
L  = vecnorm(V(B,:)-V(Br,:), 2, 2);
Ltarget  = exp((uB+uBr)/2) .* L;

%% best fit curve
gamma = bestFitCurve(L, Ltarget, k);

%% extend curve with harmonics
uv = zeros(nV, 2);
uv(B, :) = gamma;
uv(I, :) = AII \ (-AIB*gamma);

uv = uv - mean(uv, 1);

end
```
{: .snippet}

## Result

### Automatic Parameterization

<div align=center>
<img src="https://i.imgur.com/lR2rNyD.jpg" width="40%">
<img src="https://i.imgur.com/gWGmdH4.jpg" width="40%">
</div>

### Uniformization

<div align=center>
<img src="https://i.imgur.com/lR2rNyD.jpg" width="40%">
<img src="https://i.imgur.com/ZH77qLm.jpg" width="40%">
</div>

### Flatten to Square

<div align=center>
<img src="https://i.imgur.com/lR2rNyD.jpg" width="40%">
<img src="https://i.imgur.com/wxpEbVd.jpg" width="40%">
</div>

## Reference

- [Boundary First Flattening Project Homepage](https://geometrycollective.github.io/boundary-first-flattening/)
- [Boundary First Flattening Video](https://cgvr.informatik.uni-bremen.de/teaching/cg_literatur/barycentric_floater.pdf)