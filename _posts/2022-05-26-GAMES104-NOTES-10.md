---
layout: article
title: GAMES104课程笔记10-Basics Concepts in Physics System
tags: ["GAMES104", "CG"]
key: GAMES104-10
aside:
  toc: true
sidebar:
  nav: GAMES104
---

> 这个系列是GAMES104-现代游戏引擎：从入门到实践([GAMES 104: Modern Game Engine-Theory and Practice](https://games104.boomingtech.com/en/))的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍游戏引擎中物理系统的基本概念。
<!--more-->

## Introduction

物理系统是游戏引擎的重要组成部分。在游戏中玩家和整个游戏世界的互动都是依赖于物理系统的实现，同时在现代游戏中大量的粒子效果也都是通过物理系统来进行驱动的。显然物理系统非常复杂，甚至于有很多公司专门去研究物理引擎的高效实现。而在本课程中我们同样把物理系统拆分成两节，这一节课主要介绍物理引擎的基本概念而在下一节课中则会更多地讨论游戏业界更前沿的物理仿真技术。

<div align=center>
<img src="https://i.imgur.com/kBtO48C.png" width="80%">
</div>

## Physics Actors and Shapes

### Actor

在物理引擎中根据对象自身的特点我们可以把它划分为静态对象、动态对象等。其中静态对象是指在仿真过程中不会发生改变的对象，比如说游戏中的地面、墙壁等等；与之对应的是动态对象，它们的运动状态会在游戏过程中动态地进行变化，而且它们的运动过程需要符合相应的动力学模型。

<div align=center>
<img src="https://i.imgur.com/Xm6vnN2.png" width="80%">
<img src="https://i.imgur.com/n4ymCuO.png" width="80%">
</div>

除此之外游戏角色和场景的互动还需要相应的trigger，它可以用来改变对象的各种状态。

<div align=center>
<img src="https://i.imgur.com/RYJljH5.png" width="80%">
</div>

最后一个常见的物理对象是kinematics，它是指不完全基于物理法则的物理对象，但往往与玩法高度相关。

<div align=center>
<img src="https://i.imgur.com/sF9z84D.png" width="80%">
</div>

不同类型的物理对象其特点可以总结如下：

<div align=center>
<img src="https://i.imgur.com/VZF7ebZ.png" width="80%">
</div>

### Actor Shapes

物理对象最重要的属性是它的**形状(shape)**。比较规则和简单的形状可以通过解析的方法来进行描述：

<div align=center>
<img src="https://i.imgur.com/OYUnVaF.png" width="80%">
<img src="https://i.imgur.com/I8417Jw.png" width="80%">
<img src="https://i.imgur.com/KzXZQLv.png" width="80%">
<img src="https://i.imgur.com/1olcNZG.png" width="80%">
<img src="https://i.imgur.com/6Gv80w8.png" width="80%">
<img src="https://i.imgur.com/Cah4m9l.png" width="80%">
<img src="https://i.imgur.com/VrigtIo.png" width="80%">
</div>

在进行物理仿真时我们首先会把物理对象进行一定的包裹，使用相对简单的几何形状来近似复杂的模型。

<div align=center>
<img src="https://i.imgur.com/cbWhC6f.png" width="80%">
</div>

### Shape Properties

在形状的基础上我们还需要对一些物理量进行定义，包括对象的质量或密度、质心以及物理材质等。

<div align=center>
<img src="https://i.imgur.com/Ro34OGj.png" width="80%">
<img src="https://i.imgur.com/LrIqo9U.png" width="80%">
<img src="https://i.imgur.com/xllUzcI.png" width="80%">
</div>

## Forces and Movements

### Forces

**力(force)**是改变物体运动状态的原因。在物理引擎中我们同样需要力来驱动整个游戏世界的仿真过程，其中常见的类型包括重力、摩擦力等。

<div align=center>
<img src="https://i.imgur.com/7xkerkT.png" width="80%">
</div>

另一种常用的仿真方式是使用**冲量(impulse)**，它比较适合用来模拟物体运动状态发生剧烈变化的情况。

<div align=center>
<img src="https://i.imgur.com/j7rpf29.png" width="80%">
</div>

### Movements

有了力或者冲量后就可以利用牛顿运动定律来驱动物体的运动了。

<div align=center>
<img src="https://i.imgur.com/ZR6pKyo.png" width="80%">
<img src="https://i.imgur.com/ADGa3zS.png" width="80%">
</div>

在物理引擎中一般无法使用解析的方式来计算物体的运动，因此我们需要一些数值计算方法来进行求解。

<div align=center>
<img src="https://i.imgur.com/Tk1YJZ8.png" width="80%">
<img src="https://i.imgur.com/F6Tt6d1.png" width="80%">
</div>

在进行数值积分时，我们可以把时间间隔设置成一个比较小的值然后对被积函数进行累加来近似实际的积分。具体来说，在计算物体的运动轨迹时我们首先计算物体在当前位置上受到的力并且积分得到加速度，然后再利用加速度来更新速度以及物体的位置。这种计算物体运动轨迹的方法称为**Euler方法(Euler's method)**，也称为**显式积分(explicit integration)**。Euler方法实现起来非常简单，但需要注意的是它的本质是使用物体的当前状态来估计下一时刻的运动状态，此时系统的能量是不守恒的。

<div align=center>
<img src="https://i.imgur.com/by4T9LW.png" width="80%">
<img src="https://i.imgur.com/KsAsvAg.png" width="80%">
<img src="https://i.imgur.com/BqGJCpA.png" width="80%">
</div>

为了提高数值积分的稳定性，人们还开发出了**隐式积分(implicit integration)**的技术。隐式积分的实现也很简单，只需要在求解加速度和速度时使用下一时刻而不是当前时刻的值即可，同时可以证明此时系统的能量会不断衰减。当然这又引入了另一个问题，即如何计算系统在下一时刻的物理量，这在很多情况下是比较困难的。

<div align=center>
<img src="https://i.imgur.com/YHGHQVD.png" width="80%">
<img src="https://i.imgur.com/iL8tssw.png" width="80%">
</div>

在游戏引擎中更常用的积分方法是**半隐式Euler方法(semi-implicit Euler's method)**，即在计算加速度时使用当前时刻的力推导下一时刻的速度，而在计算位置时使用刚才计算出的速度再更新位置。半隐式方法有非常高的数值稳定性，广泛应用于各种类型的物理仿真中。

<div align=center>
<img src="https://i.imgur.com/8WeSzpc.png" width="80%">
<img src="https://i.imgur.com/5DqUf1w.png" width="80%">
</div>

## Rigid Body Dynamics

有了牛顿定律和数值积分算法就可以开始进行物理仿真了，其中最简单的情况是**质点动力学(particle dynamics)**。在质点动力学中所有的物体都被抽象为没有具体形状的质点，此时我们只需要按照牛顿定律更新质点的运动状态即可。

<div align=center>
<img src="https://i.imgur.com/ROnupqR.png" width="80%">
</div>

在游戏引擎中更为常见的仿真场景是**刚体动力学(rigid body dynamics)**。和质点动力学不同，刚体动力学仿真需要考虑物体自身的形状，也因此需要在质点运动的基础上引入刚体旋转的相关概念。

<div align=center>
<img src="https://i.imgur.com/7Sy9Rz2.png" width="80%">
</div>

### Orientation

刚体的**朝向(orientation)**可以使用一个旋转矩阵或者四元数来表示，它表示刚体当前姿态相对于初始姿态的旋转。

<div align=center>
<img src="https://i.imgur.com/8G908wr.png" width="80%">
</div>

### Angular Velocity

**角速度(angular velocity)**表示刚体绕某个旋转轴旋转的速度，需要注意的是在描述角速度时必须要指明旋转轴。

<div align=center>
<img src="https://i.imgur.com/2rxwk0r.png" width="80%">
</div>

### Angular Acceleration

**角加速度(angular acceleration)**类似于加速度，不过它描述的是角速度的变化。这里需要说明的是角速度的变化不仅包括绕当前轴转速的变化，它还包括旋转轴发生变化的情况。

<div align=center>
<img src="https://i.imgur.com/bS0yLoP.png" width="80%">
</div>

### Rotational Inertia

**转动惯量(rotational inertia)**类似于质量，它描述了刚体抵抗旋转的能力。转动惯量与质量的一大区别在于转动惯量不是一个常数而是一个张量(矩阵)，当刚体的朝向发生改变时需要利用旋转矩阵来计算当前姿态下的转动惯量；同时转动惯量也与刚体上的质量分布密切相关。

<div align=center>
<img src="https://i.imgur.com/4Bqa8Ec.png" width="80%">
<img src="https://i.imgur.com/3RwVNDp.png" width="80%">
</div>

### Angular Momentum

**角动量(angular momentum)**则描述了刚体旋转的状态，它是转动惯量与角速度的乘积。

<div align=center>
<img src="https://i.imgur.com/XrraRKH.png" width="80%">
</div>

### Torque

当外力不通过刚体的质心时会产生**力矩(torque)**，从而导致刚体发生旋转。

<div align=center>
<img src="https://i.imgur.com/XiK4Efj.png" width="80%">
</div>

在质点动力学的基础上把旋转部分也考虑进来对物体的运动状态进行更新就得到了刚体动力学的仿真方法。

<div align=center>
<img src="https://i.imgur.com/3eCei78.png" width="80%">
</div>

### Application：Billiard Dynamics

以台球游戏模拟为例，我们假设台球自身与桌面没有摩擦，这样台球的运动可以简化为二维平面运动。在进行仿真时需要把球杆给予台球的力(冲量)移动到球心来计算台球沿球杆方向的速度；同时这种移动还会对台球施加一个力矩使台球产生旋转，因此也需要更新台球的角速度。

<div align=center>
<img src="https://i.imgur.com/fxJYjLJ.png" width="80%">
</div>

## Collision Detection

## Collision Resolution

## Scene Query

## Efficiency, Accuracy, and Determinism

## Reference

- [Lecture 10：Physics System – Basic Concepts](https://www.bilibili.com/video/BV16U4y117VU/?spm_id_from=333.788)