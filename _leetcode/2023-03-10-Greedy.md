---
layout: article
title: 贪心
key: leetcode-09
clipboard: true
aside:
  toc: true
sidebar:
  nav: LeetCode
---

贪心算法的本质是利用局部最优来推出整体最优，不过需要注意的是很多情况下局部最优是没办法推导出整体最优的。

## 简单题目

### 455. 分发饼干

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子`i`，都有一个胃口值`g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干`j`，都有一个尺寸`s[j]`。如果`s[j] >= g[i]`，我们可以将这个饼干`j` 分配给孩子`i`，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

**示例1：**

```
输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
```

**示例2：**

```
输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
```

**提示：**

- 1 <= `g.length` <= 3 * 10⁴
- 0 <= `s.length` <= 3 * 10⁴
- 1 <= `g[i]`, `s[j]` <= 2³¹ - 1

#### Solution

本题中我们可以先对`g`和`s`进行排序，然后优先满足胃口小的孩子的需求。整个算法可以通过两个指针对`g`和`s`同时进行遍历来实现。

[题目链接](https://leetcode.cn/problems/assign-cookies/)：

```python
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g = sorted(g)
        s = sorted(s)

        i = j = 0
        res = 0

        while i < len(g) and j < len(s):
            if g[i] <= s[j]:
                i += 1
                res += 1
            
            j += 1
        
        return res
```
{: .snippet}

### 1005. K次取反后最大化的数组和

给你一个整数数组`nums`和一个整数`k`，按以下方法修改该数组：

- 选择某个下标`i`并将`nums[i]`替换为`-nums[i]`。

重复这个过程恰好`k`次。可以多次选择同一个下标`i`。

以这种方式修改数组后，返回数组**可能的最大和**。

**示例1：**

```
输入：nums = [4,2,3], k = 1
输出：5
解释：选择下标 1 ，nums 变为 [4,-2,3] 。
```

**示例2：**

```
输入：nums = [3,-1,0,2], k = 3
输出：6
解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。
```

**示例3：**

```
输入：nums = [2,-3,-1,5,-4], k = 2
输出：13
解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。
```

**提示：**

- 1 <= `nums.length` <= 10⁴
- -100 <= `nums[i]` <= 100
- 1 <= `k` <= 10⁴

#### Solution

本题的解法在于尽可能多地把`nums`中的负值修改为正值，如果全部负值都变号后还有修改次数剩余则一直修改最小的那个值。整个算法流程如下：

- 将`nums`中的数字按绝对值大小从大到小排序
- 从前向后遍历，如果`nums[i] < 0`且`k > 0`则令其变号，同时`k -= 1`
- 完成遍历后如果`k > 0`，则继续对`nums[-1]`进行变号
- 对修改后的`nums`求和即为所求

[题目链接](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)：

```python
class Solution:
    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:
        ## sort the array with abs
        nums = sorted(nums, key=abs, reverse=True)

        ## change signs of negative num
        for i in range(len(nums)):
            if nums[i] < 0 and k > 0:
                nums[i] *= -1
                k -= 1
        
        if k > 0:
            nums[-1] *= (-1)**k
        
        return sum(nums)
```
{: .snippet}

### 860. 柠檬水找零

在柠檬水摊上，每一杯柠檬水的售价为`5`美元。顾客排队购买你的产品，(按账单`bills`支付的顺序)一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付`5`美元、`10`美元或`20`美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付`5`美元。

注意，一开始你手头没有任何零钱。

给你一个整数数组`bills`，其中`bills[i]`是第`i`位顾客付的账。如果你能给每位顾客正确找零，返回`true`，否则返回`false`。

**示例1：**

```
输入：bills = [5,5,5,10,20]
输出：true
解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 true。
```

**示例2：**

```
输入：bills = [5,5,10,10,20]
输出：false
解释：
前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
由于不是每位顾客都得到了正确的找零，所以答案是 false。
```

**提示：**

- 1 <= `bills.length` <= 10⁵
- `bills[i]`不是`5`就是`10`或是`20`

#### Solution

本题中根据`bills[i]`有以下找零情况：

- `bills[i] == 5`时无需找零
- `bills[i] == 10`时需要1张`5`元
- `bills[i] == 20`时需要3张`5`元，或者1张`10`元和1张`5`元

因此`5`元的功能要比`10`元多一些，在找零时我们则应该尽可能先找`10`元然后再找`5`元。基于这样的观察，我们可以使用`five`和`ten`来记录已经收到的`5`元和`10`元数量，然后在找零时进行相应地递减。如果任意一个变量小于0则说明无法继续找零，返回`False`；否则继续遍历直到结束，返回`True`。

[题目链接](https://leetcode.cn/problems/lemonade-change/)：

```python
class Solution:
    def lemonadeChange(self, bills: List[int]) -> bool:
        five = ten = 0

        for bill in bills:
            if bill == 5:
                five += 1
            elif bill == 10:
                if five < 0:
                    return False
                
                five -= 1
                ten  += 1
            else:
                if five > 0 and ten > 0:
                    five -= 1
                    ten  -= 1
                elif five > 2:
                    five -= 3
                else:
                    return False
        
        return True
```
{: .snippet}

## 序列问题

### 376. 摆动序列

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为**摆动序列**。第一个差(如果存在的话)可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如，`[1, 7, 4, 9, 2, 5]`是一个**摆动序列**，因为差值`(6, -3, 5, -7, 3)`是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]`和`[1, 7, 4, 5, 5]`不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

**子序列**可以通过从原始序列中删除一些(也可以不删除)元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组`nums`，返回`nums`中作为**摆动序列**的**最长子序列的长度**。

**示例1：**

```
输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
```

**示例2：**

```
输入：nums = [1,17,5,10,13,15,10,5,16,8]
输出：7
解释：这个序列包含几个长度为 7 摆动序列。
其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
```

**示例3：**

```
输入：nums = [1,2,3,4,5,6,7,8,9]
输出：2
```

**提示：**

- 1 <= `nums.length` <= 1000
- 0 <= `nums[i]` <= 1000

#### Solution

本题的技巧在于把数组想象成高度，这样最长摆动子序列的长度就是山峰和山谷的数目。

<div align=center>
<img src="https://images.weserv.nl/?url=i.imgur.com/4Tg6C4D.png" width="90%">
</div>

接下来考虑一些可能出现的情况。如果出现了平坡则需要把平的地方去掉。

<div align=center>
<img src="https://images.weserv.nl/?url=i.imgur.com/RPmjBMH.png" width="90%">
<img src="https://images.weserv.nl/?url=i.imgur.com/r1MEDA8.png" width="90%">
</div>

总结一下，我们需要两个变量`curDiff`和`preDiff`记录当前位置和上一个山峰山谷的高度差。当`curDiff * preDiff <= 0`时说明当前位置可能符合摆动序列，需要进一步判断`curDiff`是否为0。如果`curDiff == 0`说明当前位于平坡上需要越过，否则对`preDiff`进行更新。整个算法流程可以参考如下。

[题目链接](https://leetcode.cn/problems/wiggle-subsequence/)：

```python
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        res = 1
        curDiff, preDiff = 0, 0

        for i in range(len(nums)-1):
            curDiff = nums[i+1] - nums[i]

            if curDiff * preDiff <= 0 and curDiff != 0:
                res += 1
                preDiff = curDiff

        return res
```
{: .snippet}

### 53. 最大子数组和

给你一个整数数组`nums`，请你找出一个具有最大和的连续子数组(子数组最少包含一个元素)，返回其最大和。

**子数组**是数组中的一个连续部分。

**示例1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**示例2：**

```
输入：nums = [1]
输出：1
```

**示例3：**

```
输入：nums = [5,4,-1,7,8]
输出：23
```

**提示：**

- 1 <= `nums.length` <= 10⁵
- -10⁴ <= `nums[i]` <= 10⁴

#### Solution

本题中我们需要使用变量`cur`记录当前的子列之和，用`res`记录遇见过的最大子列之和。`cur < 0`时子列累加新的数字不如重新开始，因此我们重置子列起点并将`cur`设置为`0`。这样只需对`nums`进行一次遍历即可。

[题目链接](https://leetcode.cn/problems/maximum-subarray/)：

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        N = len(nums)

        res = -float("inf")
        cur = 0

        for i in range( N):
            cur += nums[i]

            ## update res
            if cur > res:
                res = cur
            
            ## reset
            if cur < 0:
                cur = 0

        return res
```
{: .snippet}

本题的另一种解法是利用动态规划。我们定义一个数组`p[]`，其中`p[i]`表示以`nums[i]`结尾的和最大的子列的和。当我们得到`p[i-1]`之后，`p[i]`有两种情况：

1. `nums[i]`在以`nums[i-1]`结尾的子列之中，此时`p[i] = p[i-1]+nums[i]`
2. `nums[i]`不在以`nums[i-1]`结尾的子列之中，此时需要开启一个新的子列`p[i] = nums[i]`

这样就得到递推关系`p[i] = max(p[i-1]+nums[i], nums[i])`。完成递推后选择最大的`p[i]`即可。

[题目链接](https://leetcode.cn/problems/maximum-subarray/)：

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        N = len(nums)
        p = [nums[0] for _ in range(N)]
        
        for i in range(1, N):
            p[i] = max(p[i-1]+nums[i], nums[i])
        
        return max(p)
```
{: .snippet}

## 股票问题

### 122. 买卖股票的最佳时机 II

给你一个整数数组`prices`，其中`prices[i]`表示某支股票第`i`天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候**最多**只能持有**一股**股票。你也可以先购买，然后在**同一天**出售。

返回 你能获得的**最大**利润。

**示例1：**

```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。
```

**示例2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     总利润为 4 。
```

**示例3：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
```

**提示：**

- 1 <= `prices.length` <= 3*10⁴
- 0 <= `prices[i]` <= 10⁴

#### Solution

本题的贪心解法是尽可能多地进行交易，然后只选择其中利润大于0的，这样就能得到最大利润。

<div align=center>
<img src="https://images.weserv.nl/?url=i.imgur.com/4rvf4Su.png" width="70%">
</div>

[题目链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)：

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        res = 0

        for i in range(1, len(prices)):
            profit = prices[i] - prices[i-1]
            if profit > 0:
                res += profit

        return res
```
{: .snippet}

本题的另一种解法是利用动态规划。我们定义一个数组`p[]`，其中`p[i]`表示以第`i`天的最大利润。当我们得到`p[i-1]`之后，`p[i]`有两种情况：

1. 买入第`i`天的股票并卖出，此时`p[i] = p[i-1] + (prices[i] - prices[i-1])`
2. 什么也不做，此时`p[i] = p[i-1]`

这样就得到递推关系`p[i] = p[i-1] + max(0, prices[i] - prices[i-1])`。完成递推后直接返回最后一位`p[-1]`即可。

[题目链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)：

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        N = len(prices)

        p = [0 for _ in range(N)]

        for i in range(1, N):
            p[i] = p[i-1] + max(0, prices[i] - prices[i-1])
            
        return p[-1]
```
{: .snippet}

## 区间问题

### 55. 跳跃游戏

给定一个非负整数数组`nums`，你最初位于数组的**第一个下标**。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

**示例1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**示例2：**

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

**提示：**

- 1 <= `nums.length` <= 3*10⁴
- 0 <= `nums[i]` <= 10⁵

#### Solution

本题的解法是使用一个变量`cover`来记录棋子当前能够到达的最远距离。在初始状态下`cover = nums[0]`，此时棋子可以到达`[0, cover]`之间的任意位置。然后我们对所有能够到达的位置`i`进行遍历，同时更新`cover = max(cover, i+nums[i])`。如果`cover >= len(nums)-1`说明棋子可以移动到终点，直接返回`True`；而如果`i`移动到`cover`位置还没有返回则说明无法移动到终点，返回`False`。

[题目链接](https://leetcode.cn/problems/jump-game/)：

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        i = 0
        cover = nums[0]

        while i <= cover:
            cover = max(cover, i+nums[i])

            if cover >= len(nums)-1:
                return True
            
            i += 1
        
        return False
```
{: .snippet}

### 45. 跳跃游戏 II

给定一个长度为`n`的**0索引**整数数组`nums`。初始位置为`nums[0]`。

每个元素`nums[i]`表示从索引`i`向前跳转的最大长度。换句话说，如果你在`nums[i]`处，你可以跳转到任意`nums[i + j]`处:

- 0 <= `j` <= `nums[i]`
- i + j < n

返回到达`nums[n - 1]`的最小跳跃次数。生成的测试用例可以到达`nums[n - 1]`。

**示例1：**

```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

**示例2：**

```
输入: nums = [2,3,0,1,4]
输出: 2
```

**提示：**

- 1 <= `nums.length` <= 10⁴
- 0 <= `nums[i]` <= 1000
- 题目保证可以到达`nums[n-1]`

#### Solution

本题要比[跳跃游戏](/leetcode/2023-03-10-Greedy.html#55-跳跃游戏)复杂一些。我们需要使用两个指针：`end`用来记录当前能够到达的最远端，`cover`用来记录下一个区域的最远端。在位置`i`处进行更新`cover = max(cover, i+nums[i])`，到达`end`后再使用`cover`来更新`end`即可。

<div align=center>
<img src="https://images.weserv.nl/?url=i.imgur.com/iUYd7tg.png" width="40%">
</div>

[题目链接](https://leetcode.cn/problems/jump-game-ii/)：

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        N = len(nums)
        res = 0

        end = cover = 0

        for i in range(N-1):
            cover = max(cover, i+nums[i])

            if i == end:
                res += 1
                end = cover

        return res
```
{: .snippet}

## 权衡问题

### 135. 分发糖果

`n`个孩子站成一排。给你一个整数数组`ratings`表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到`1`个糖果。
- 相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的**最少糖果数目**。

**示例1：**

```
输入：ratings = [1,0,2]
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
```

**示例2：**

```
输入：ratings = [1,2,2]
输出：4
解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。
```

**提示：**

- `n` == `ratings.length`
- 1 <= `n` <= 2 * 10⁴
- 0 <= `ratings[i]` <= 2 * 10⁴

#### Solution

本题的难点在于理解题意，实际上题目要求可以表述如下：

- 左规则：当`ratings[i-1] < ratings[i]`时，`candies[i] > candies[i-1]`
- 右规则：当`ratings[i] > ratings[i+1]`时，`candies[i] > candies[i+1]`

这样我们就可以通过两次遍历来求出每个孩子获得的糖果数。整个算法流程可以参考如下。

<div align=center>
<img src="https://images.weserv.nl/?url=i.imgur.com/sx7iieD.png" width="80%">
</div>

[题目链接](https://leetcode.cn/problems/candy/)：

```python
class Solution:
    def candy(self, ratings: List[int]) -> int:
        N = len(ratings)
        candies = [1 for _ in range(N)]

        ## left to right
        for i in range(1, N):
            if ratings[i-1] < ratings[i]:
                candies[i] = candies[i-1]+1

        ## right to left
        for i in range(N-2, -1, -1):
            if ratings[i+1] < ratings[i]:
                candies[i] = max(candies[i], candies[i+1]+1)

        return sum(candies)
```
{: .snippet}

### 406. 根据身高重建队列

假设有打乱顺序的一群人站成一个队列，数组`people`表示队列中一些人的属性(不一定按顺序)。每个`people[i] = [hᵢ, kᵢ]`表示第`i`个人的身高为`hᵢ`，前面**正好**有`kᵢ`个身高大于或等于`hᵢ`的人。

请你重新构造并返回输入数组`people`所表示的队列。返回的队列应该格式化为数组`queue`，其中`queue[j] = [hⱼ, kⱼ]`是队列中第`j`个人的属性(`queue[0]`是排在队列前面的人)。

**示例1：**

```
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
```

**示例2：**

```
输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
```

**提示：**

- 1 <= `people.length` <= 2000
- 0 <= hᵢ <= 10⁵
- 0 <= `kᵢ` < `people.length`
- 题目数据确保队列可以被重建

#### Solution

本题中我们需要对`people`中的元素按照身高从大到小排序，对于身高一样的则按照`kᵢ`进行排序。排序后我们对`people`进行遍历，然后按照每个元素的`kᵢ`进行插入来重新构造一个新的数组，这样可以保证它前面正好有`kᵢ`个比它高的元素。

[题目链接](https://leetcode.cn/problems/queue-reconstruction-by-height/)：

```python
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        people = sorted(people, key= lambda p: (-p[0], p[1]))

        queue = []
        for p in people:
            queue.insert(p[1], p)
        
        return queue
```
{: .snippet}

## 其它

### 134. 加油站

在一条环路上有`n`个加油站，其中第`i`个加油站有汽油`gas[i]`升。

你有一辆油箱容量无限的的汽车，从第`i`个加油站开往第`i+1`个加油站需要消耗汽油`cost[i]`升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组`gas`和`cost`，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则**保证**它是**唯一**的。

**示例1：**

```
输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
输出: 3
解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。
```

**示例2：**

```
输入: gas = [2,3,4], cost = [3,4,3]
输出: -1
解释:
你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
因此，无论怎样，你都不可能绕环路行驶一周。
```

**提示：**

- `gas.length` == `n`
- `cost.length` == `n`
- 1 <= `n` <= 10⁵
- 0 <= `gas[i]`, `cost[i]` <= 10⁴

#### Solution

本题的暴力解法是从每一个加油站出发尝试行驶一圈，如果能完成一圈则返回起始加油站编号，否则返回`-1`。显然暴力解法的复杂度为`O(n²)`，说明这并不是一种高效的解法。

本题的贪心解法需要使用两个变量`start`来记录起始加油站编号，以及`cur`来记录`start`到当前加油站时剩余的汽油量。首先我们需要判断是否存在解，即是否满足`sum(gas) >= sum(cost)`，如果不满足则直接返回`-1`。然后从`start = 0`开始遍历，更新`cur += gas[i] - cost[i]`作为`start`到`i`位置剩余的汽油量。如果`cur < 0`则说明从`start`出发会出现油量不足的问题，更进一步来说从区间`[start, i]`上的任意位置出发经过`i`都会出现油量不足，因此我们需要令`start = i+1`重新进行尝试并将`cur`置零。完成遍历后`start`即为所求。

<div align=center>
<img src="https://images.weserv.nl/?url=i.imgur.com/NrakAVp.png" width="50%">
</div>

[题目链接](https://leetcode.cn/problems/gas-station/)：

```python
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        if sum(gas) < sum(cost):
            return -1

        cur = 0
        start = 0

        for i in range(len(gas)):
            cur += gas[i] - cost[i]

            if cur < 0:
                cur = 0
                start = i+1
        
        return start
```
{: .snippet}

## Reference

- [贪心算法理论基础](https://www.bilibili.com/video/BV1WK4y1R71x/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)
- [LeetCode：455.分发饼干](https://www.bilibili.com/video/BV1MM411b7cq/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)
- [LeetCode：376.摆动序列](https://www.bilibili.com/video/BV17M411b7NS/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)
- [LeetCode：53.最大子序和](https://www.bilibili.com/video/BV1aY4y1Z7ya/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)
- [LeetCode：122.买卖股票最佳时机II](https://www.bilibili.com/video/BV1ev4y1C7na/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)
- [LeetCode：55.跳跃游戏](https://www.bilibili.com/video/BV1VG4y1X7kB/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)
- [LeetCode：45.跳跃游戏II](https://www.bilibili.com/video/BV1Y24y1r7XZ/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)
- [LeetCode：1005.K次取反后最大化的数组和](https://www.bilibili.com/video/BV138411G7LY/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)
- [LeetCode：134.加油站](https://www.bilibili.com/video/BV1jA411r7WX/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)
- [LeetCode：135.分发糖果](https://www.bilibili.com/video/BV1ev4y1r7wN/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)
- [LeetCode：860.柠檬水找零](https://www.bilibili.com/video/BV12x4y1j7DD/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)
- [LeetCode：406.根据身高重建队列](https://www.bilibili.com/video/BV1EA411675Y/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)