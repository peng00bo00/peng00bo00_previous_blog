---
layout: article
title: 图论
key: leetcode-12
clipboard: true
aside:
  toc: true
sidebar:
  nav: LeetCode
---

## DFS

**深度优先搜索(DFS)**是对图进行遍历的基本方法，它等同于前面介绍过的[回溯](/leetcode/2023-03-04-Backtracking.html)。因此DFS算法的基本框架可参考回溯模板如下。

```
def dfs(节点，参数):
    if 终止条件:
        存放结果
        return
    
    for (选择：与节点相邻的其它节点):
        处理节点
        dfs(选择的节点)
        回溯(撤销对节点的处理)
```

### 797. 所有可能的路径

给你一个有`n`个节点的**有向无环图(DAG)**，请你找出所有从节点`0`到节点`n-1`的路径并输出(不要求按特定顺序)。

`graph[i]`是一个从节点`i`可以访问的所有节点的列表(即从节点`i`到节点`graph[i][j]`存在一条有向边)。

**示例1：**

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/09/28/all_1.jpg">
</div>

```
输入：graph = [[1,2],[3],[3],[]]
输出：[[0,1,3],[0,2,3]]
解释：有两条路径 0 -> 1 -> 3 和 0 -> 2 -> 3
```

**示例2：**

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/09/28/all_2.jpg">
</div>

```
输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]
输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]
```

**提示：**

- `n` == `graph.length`
- 2 <= `n` <= 15
- 0 <= `graph[i][j]` < `n`
- `graph[i][j]` != `i` (即不存在自环)
- `graph[i]`中的所有元素**互不相同**
- 保证输入为**有向无环图(DAG)**

#### Solution

本题需要使用DFS来遍历起点`0`到终点`n-1`的所有路径，当到达终点`n-1`时将路径`path`添加到结果`res`中即可。

[题目链接](https://leetcode.cn/problems/all-paths-from-source-to-target/)：

```python
class Solution:
    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
        N = len(graph)

        path = [0]
        res = []

        def dfs(node: int) -> None:
            nonlocal path, res
            
            if node == N-1:
                res.append(path[:])
                return
            
            for v in graph[node]:
                path.append(v)
                dfs(v)
                path.pop()
        
        dfs(0)

        return res
```
{: .snippet}

### 200. 岛屿数量

给你一个由`'1'`(陆地)和`'0'`(水)组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

**提示：**

- `m` == `grid.length`
- `n` == `grid[i].length`
- 1 <= `m`, `n` <= 300
- `grid[i][j]`的值为`'0'`或`'1'`

#### Solution

本题的解法在于对整个地图进行遍历，每遇到一个岛屿就对所有和它相连的陆地进行标记并令岛屿记数`res`加`1`。本题的DFS解法可参考如下。

[题目链接](https://leetcode.cn/problems/number-of-islands/)：

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        H = len(grid)
        W = len(grid[0])

        visited = [[0 for j in range(W)] for i in range(H)]
        res = 0

        def dfs(x: int, y: int) -> None:
            nonlocal visited

            visited[y][x] = 1
            
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                if 0 <= x+dx < W and 0 <= y+dy < H and grid[y+dy][x+dx] == '1' and not visited[y+dy][x+dx]:
                    dfs(x+dx, y+dy)
        
        for y in range(H):
            for x in range(W):
                if grid[y][x] == '1' and not visited[y][x]:
                    dfs(x, y)
                    res += 1
            
        return res
```
{: .snippet}

### 695. 岛屿的最大面积

给你一个大小为`m x n`的二进制矩阵`grid`。

**岛屿**是由一些相邻的`1`(代表土地)构成的组合，这里的「相邻」要求两个`1`必须在**水平或者竖直的四个方向上**相邻。你可以假设`grid`的四个边缘都被`0`(代表水)包围着。

岛屿的面积是岛上值为`1`的单元格的数目。

计算并返回`grid`中最大的岛屿面积。如果没有岛屿，则返回面积为`0`。

**示例1：**

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg"  width="70%">
</div>

```
输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
输出：6
解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。
```

**示例2：**

```
输入：grid = [[0,0,0,0,0,0,0,0]]
输出：0
```

**提示：**

- `m` == `grid.length`
- `n` == `grid[i].length`
- 1 <= `m`, `n` <= 50
- `grid[i][j]`的值为`0`或`1`

#### Solution

本题的解法类似于[岛屿数量](/leetcode/2023-03-29-Graph.html#200-岛屿数量)，不过在DFS过程中需要把当前岛屿的面积记录在变量`A`中并且对所有的岛屿面积取最大值。

[题目链接](https://leetcode.cn/problems/max-area-of-island/)：

```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        M = len(grid)
        N = len(grid[0])

        visited = [[0 for j in range(N)] for i in range(M)]
        res = A = 0

        def dfs(x: int, y: int) -> None:
            nonlocal visited, A

            visited[y][x] = 1
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                if 0 <= y+dy < M and 0 <= x+dx < N and grid[y+dy][x+dx] and not visited[y+dy][x+dx]:
                    A += 1
                    dfs(x+dx, y+dy)
            
        
        for y in range(M):
            for x in range(N):
                if grid[y][x] and not visited[y][x]:
                    A = 1
                    dfs(x, y)
                    res = max(res, A)
        
        return res
```
{: .snippet}

### 1020. 飞地的数量

给你一个大小为`m x n`的二进制矩阵`grid`，其中`0`表示一个海洋单元格、`1`表示一个陆地单元格。

一次**移动**是指从一个陆地单元格走到另一个相邻(**上**、**下**、**左**、**右**)的陆地单元格或跨过`grid`的边界。

返回网格中**无法**在任意次数的移动中离开网格边界的陆地单元格的数量。

**示例1：**

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/18/enclaves1.jpg">
</div>

```
输入：grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
输出：3
解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。
```

**示例2：**

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/18/enclaves2.jpg">
</div>

```
输入：grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
输出：0
解释：所有 1 都在边界上或可以到达边界。
```

**提示：**

- `m` == `grid.length`
- `n` == `grid[i].length`
- 1 <= `m`, `n` <= 500
- `grid[i][j]`的值为`0`或`1`

#### Solution

本题的难点在于如何判断一块岛屿是否是飞地。实际上我们可以先从`grid`的四条边出发把所有和边相连的岛屿(绿色)都修改成海洋，这样`grid`剩余的岛屿(黄色)就都是飞地了。本题的DFS解法可参考如下。

<div align=center>
<img src="https://images.weserv.nl/?url=i.imgur.com/PBqOhHS.png"  width="70%">
</div>

[题目链接](https://leetcode.cn/problems/number-of-enclaves/)：

```python
class Solution:
    def numEnclaves(self, grid: List[List[int]]) -> int:
        M = len(grid)
        N = len(grid[0])

        res = 0

        def dfs(x: int, y: int) -> None:
            nonlocal grid, res

            grid[y][x] = 0
            res += 1

            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                if 0 <= y+dy < M and 0 <= x+dx < N and grid[y+dy][x+dx]:
                    dfs(x+dx, y+dy)
        
        for y in range(M):
            if grid[y][0]:
                dfs(0, y)
            if grid[y][N-1]:
                dfs(N-1, y)
        
        for x in range(N):
            if grid[0][x]:
                dfs(x, 0)
            if grid[M-1][x]:
                dfs(x, M-1)
        
        res = 0
        for y in range(M):
            for x in range(N):
                if grid[y][x]:
                    dfs(x, y)

        return res
```
{: .snippet}

### 130. 被围绕的区域

给你一个`m x n`的矩阵`board`，由若干字符`'X'`和`'O'`，找到所有被`'X'`围绕的区域，并将这些区域里所有的`'O'`用`'X'`填充。

**示例1：**

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/19/xogrid.jpg">
</div>

```
输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。
```

**示例2：**

```
输入：board = [["X"]]
输出：[["X"]]
```

**提示：**

- `m` == `board.length`
- `n` == `board[i].length`
- 1 <= `m`, `n` <= 200
- `board[i][j]`为`'X'`或`'O'`

#### Solution

本题的解法类似于[飞地的数量](/leetcode/2023-03-29-Graph.html#1020-飞地的数量)。我们只需要先标记`board`中与边界相连的岛屿，然后对`board`进行遍历把所有未标记过的岛屿到填充为`'X'`即可。本题的DFS解法可参考如下。

[题目链接](https://leetcode.cn/problems/surrounded-regions/)：

```python
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """

        M = len(board)
        N = len(board[0])

        visited = [[0 for j in range(N)] for i in range(M)]

        def dfs(x: int, y: int) -> None:
            nonlocal visited

            visited[y][x] = 1
            
            for dx, dy in [(0, 1), (0,-1), (1, 0), (-1, 0)]:
                if 0 <= y+dy < M and 0 <= x+dx < N and board[y+dy][x+dx] == "O" and not visited[y+dy][x+dx]:
                    dfs(x+dx, y+dy)
        
        for y in range(M):
            if board[y][0] == "O":
                dfs(0, y)
            
            if board[y][N-1] == "O":
                dfs(N-1, y)
        
        for x in range(N):
            if board[0][x] == "O":
                dfs(x, 0)
            
            if board[M-1][x] == "O":
                dfs(x, M-1)
        
        for y in range(M):
            for x in range(N):
                if board[y][x] == "O" and not visited[y][x]:
                    board[y][x] = "X"
```
{: .snippet}

### 417. 太平洋大西洋水流问题

有一个`m × n`的矩形岛屿，与**太平洋**和**大西洋**相邻。**"太平洋"**处于大陆的左边界和上边界，而**"大西洋"**处于大陆的右边界和下边界。

这个岛被分割成一个由若干方形单元格组成的网格。给定一个`m x n`的整数矩阵`heights`，`heights[r][c]`表示坐标`(r, c)`上单元格**高于海平面的高度**。

岛上雨水较多，如果相邻单元格的高度**小于或等于**当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。

返回网格坐标`result`的**2D 列表**，其中`result[i] = [ri, ci]`表示雨水从单元格`(ri, ci)`流动**既可流向太平洋也可流向大西洋**。

**示例1：**

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg">
</div>

```
输入: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
输出: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
```

**示例2：**

```
输入: heights = [[2,1],[1,2]]
输出: [[0,0],[0,1],[1,0],[1,1]]
```

**提示：**

- `m` == `heights.length`
- `n` == `heights[r].length`
- 1 <= `m`, `n` <= 200
- 0 <= `heights[r][c]` <= 10⁵

#### Solution

本题的直接解法是对网格中的每一个位置进行遍历，如果它能够同时流向太平洋和大西洋则将其加入到`res`中。然而这样的直接解法的复杂度为`O(m²n²)`，会出现超时的问题。

因此本题中我们需要从反方向进行思考。假设水流可以从太平洋和大西洋按高度逆流到网格中，如果某个位置能够同时接收到两个方向的水流则将它加入到`res`中。从这样的角度我们只需要对网格的四边进行遍历，标记那些能够接收到来自太平洋和大西洋水流的节点即可。优化后的算法复杂度为`O(mn)`，其DFS实现可以参考如下。

<div align=center>
<img src="https://images.weserv.nl/?url=i.imgur.com/8OFuf65.png" width="40%">
<img src="https://images.weserv.nl/?url=i.imgur.com/eS4g3BD.png" width="40%">
</div>

[题目链接](https://leetcode.cn/problems/pacific-atlantic-water-flow/)：

```python
class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        M = len(heights)
        N = len(heights[0])

        visited = [[[0, 0] for j in range(N)] for i in range(M)]
        res = []

        def dfs(r: int, c: int, src: int) -> None:
            nonlocal visited
            
            for dr, dc in [(0, 1), (0,-1), (1, 0), (-1, 0)]:
                rr = r + dr
                cc = c + dc

                if 0 <= rr < M and 0 <= cc < N and heights[rr][cc] >= heights[r][c] and not visited[rr][cc][src]:
                    visited[rr][cc][src] = 1
                    dfs(rr, cc, src)
        
        for r in range(M):
            visited[r][0][0] = 1
            visited[r][N-1][1] = 1

            dfs(r, 0, 0)
            dfs(r, N-1, 1)
        
        for c in range(N):
            visited[0][c][0] = 1
            visited[M-1][c][1] = 1

            dfs(0, c, 0)
            dfs(M-1, c, 1)
        
        for r in range(M):
            for c in range(N):
                if visited[r][c][0] and visited[r][c][1]:
                    res.append([r, c])
        
        return res
```
{: .snippet}

### 827. 最大人工岛

给你一个大小为`n x n`二进制矩阵`grid`。最多**只能将一格**`0`变成`1`。

返回执行此操作后，`grid`中最大的岛屿面积是多少？

**岛屿**由一组上、下、左、右四个方向相连的`1`形成。

**示例1：**

```
输入: grid = [[1, 0], [0, 1]]
输出: 3
解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。
```

**示例2：**

```
输入: grid = [[1, 1], [1, 0]]
输出: 4
解释: 将一格0变成1，岛屿的面积扩大为 4。
```

**示例3：**

```
输入: grid = [[1, 1], [1, 1]]
输出: 4
解释: 没有0可以让我们变成1，面积依然为 4。
```

**提示：**

- `n` == `grid.length`
- `n` == `grid[r].length`
- 1 <= `n` <= 500
- `grid[i][j]`为`0`或`1`

#### Solution

本题的暴力解法是尝试将`grid`中每个海洋单元格修改为`1`然后计算此时的最大岛屿面积。显然这种做法有过高的时间复杂度，会直接导致超时。

因此本题的解法在于对`grid`进行两次遍历。在第一次遍历中记录下每个岛屿的面积，而在第二次遍历中尝试将原来的海洋单元格修改为陆地并累加所有和它相连的不同岛屿面积。本题的DFS解法可参考如下。

<div align=center>
<img src="https://images.weserv.nl/?url=i.imgur.com/4yp6rTP.png" width="70%">
</div>

[题目链接](https://leetcode.cn/problems/making-a-large-island/)：

```python
class Solution:
    def largestIsland(self, grid: List[List[int]]) -> int:
        N = len(grid)

        visited = [[0 for j in range(N)] for i in range(N)]

        As = {}
        Amax = 0

        def dfs(x: int, y: int, label: int) -> None:
            nonlocal visited, A

            visited[y][x] = label
            A += 1

            for dx, dy in [(0, 1), (0,-1), (1, 0), (-1, 0)]:
                xx = x + dx
                yy = y + dy

                if 0 <= yy < N and 0 <= xx < N and grid[yy][xx] and not visited[yy][xx]:
                    dfs(xx, yy, label)

        ## first loop
        for y in range(N):
            for x in range(N):
                if grid[y][x] and not visited[y][x]:
                    A = 0
                    label = len(As)+1

                    dfs(x, y, label)
                    As[label] = A
                    Amax = max(Amax, A)
        
        ## second loop
        for y in range(N):
            for x in range(N):
                if not visited[y][x]:
                    A = 1
                    connect = []

                    for dx, dy in [(0, 1), (0,-1), (1, 0), (-1, 0)]:
                        xx = x + dx
                        yy = y + dy

                        if 0 <= yy < N and 0 <= xx < N and visited[yy][xx] and visited[yy][xx] not in connect:
                            A += As[visited[yy][xx]]
                            connect.append(visited[yy][xx])
                    
                    Amax = max(Amax, A)

        return Amax
```
{: .snippet}

## BFS

**广度优先搜索(BFS)**的实现类似于[层序遍历](/leetcode/2023-02-03-BinaryTree.html#102-二叉树的层序遍历)。在BFS中我们需要使用一个队列来依次保存需要拓展的节点，当队列非空时弹出新的节点进行拓展。

### 200. 岛屿数量

给你一个由`'1'`(陆地)和`'0'`(水)组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

**提示：**

- `m` == `grid.length`
- `n` == `grid[i].length`
- 1 <= `m`, `n` <= 300
- `grid[i][j]`的值为`'0'`或`'1'`

#### Solution

本题的BFS解法可参考如下。需要注意的是BFS在实现时每当有节点**入队**就将其标记为`visited`，否则会出现很多节点多次加入队列的情况从而导致超时。

[题目链接](https://leetcode.cn/problems/number-of-islands/)：

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        H = len(grid)
        W = len(grid[0])

        visited = [[0 for j in range(W)] for i in range(H)]
        res = 0

        def bfs(x: int, y: int) -> None:
            from collections import deque

            nonlocal visited
            
            visited[y][x] = 1
            queue = deque([(x, y)])

            while queue:
                x, y = queue.popleft()
            
                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    if 0 <= x+dx < W and 0 <= y+dy < H and grid[y+dy][x+dx] == '1' and not visited[y+dy][x+dx]:
                        queue.append((x+dx, y+dy))
                        visited[y+dy][x+dx] = 1
        
        for y in range(H):
            for x in range(W):
                if grid[y][x] == '1' and not visited[y][x]:
                    bfs(x, y)
                    res += 1
            
        return res
```
{: .snippet}

### 695. 岛屿的最大面积

给你一个大小为`m x n`的二进制矩阵`grid`。

**岛屿**是由一些相邻的`1`(代表土地)构成的组合，这里的「相邻」要求两个`1`必须在**水平或者竖直的四个方向上**相邻。你可以假设`grid`的四个边缘都被`0`(代表水)包围着。

岛屿的面积是岛上值为`1`的单元格的数目。

计算并返回`grid`中最大的岛屿面积。如果没有岛屿，则返回面积为`0`。

**示例1：**

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg" width="70%">
</div>

```
输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
输出：6
解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。
```

**示例2：**

```
输入：grid = [[0,0,0,0,0,0,0,0]]
输出：0
```

**提示：**

- `m` == `grid.length`
- `n` == `grid[i].length`
- 1 <= `m`, `n` <= 50
- `grid[i][j]`的值为`0`或`1`

#### Solution

本题的解法类似于[岛屿数量](/leetcode/2023-03-29-Graph.html#200-岛屿数量-1)，不过在BFS过程中需要把当前岛屿的面积记录在变量`A`中并且对所有的岛屿面积取最大值。

[题目链接](https://leetcode.cn/problems/max-area-of-island/)：

```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        M = len(grid)
        N = len(grid[0])

        visited = [[0 for j in range(N)] for i in range(M)]
        res = 0

        def bfs(x: int, y: int) -> int:
            from collections import deque

            queue = deque([(x, y)])
            A = 1

            nonlocal visited
            visited[y][x] = 1

            while queue:
                x, y = queue.popleft()

                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    if 0 <= y+dy < M and 0 <= x+dx < N and grid[y+dy][x+dx] and not visited[y+dy][x+dx]:
                        queue.append((x+dx, y+dy))
                        visited[y+dy][x+dx] = 1

                        A += 1
            
            return A     
        
        for y in range(M):
            for x in range(N):
                if grid[y][x] and not visited[y][x]:
                    A = bfs(x, y)
                    res = max(res, A)
        
        return res
```
{: .snippet}

### 1020. 飞地的数量

给你一个大小为`m x n`的二进制矩阵`grid`，其中`0`表示一个海洋单元格、`1`表示一个陆地单元格。

一次**移动**是指从一个陆地单元格走到另一个相邻(**上**、**下**、**左**、**右**)的陆地单元格或跨过`grid`的边界。

返回网格中**无法**在任意次数的移动中离开网格边界的陆地单元格的数量。

**示例1：**

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/18/enclaves1.jpg">
</div>

```
输入：grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
输出：3
解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。
```

**示例2：**

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/18/enclaves2.jpg">
</div>

```
输入：grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
输出：0
解释：所有 1 都在边界上或可以到达边界。
```

**提示：**

- `m` == `grid.length`
- `n` == `grid[i].length`
- 1 <= `m`, `n` <= 500
- `grid[i][j]`的值为`0`或`1`

#### Solution

本题的BFS解法可参考如下。

[题目链接](https://leetcode.cn/problems/number-of-enclaves/)：

```python
class Solution:
    def numEnclaves(self, grid: List[List[int]]) -> int:
        M = len(grid)
        N = len(grid[0])

        res = 0

        def bfs(x: int, y: int) -> None:
            from collections import deque

            nonlocal grid, res

            queue = deque([(x, y)])
            grid[y][x] = 0
            res += 1

            while queue:
                x, y = queue.popleft()

                for dx, dy in [(0, 1), (0,-1), (1, 0), (-1, 0)]:
                    if 0 <= y+dy < M and 0 <= x+dx < N and grid[y+dy][x+dx]:
                        queue.append((x+dx, y+dy))
                        
                        grid[y+dy][x+dx] = 0
                        res += 1
        
        for y in range(M):
            if grid[y][0]:
                bfs(0, y)
            
            if grid[y][N-1]:
                bfs(N-1, y)
        
        for x in range(N):
            if grid[0][x]:
                bfs(x, 0)
            
            if grid[M-1][x]:
                bfs(x, M-1)
        
        res = 0
        for y in range(M):
            for x in range(N):
                if grid[y][x]:
                    bfs(x, y)
            
        return res
```
{: .snippet}

### 130. 被围绕的区域

给你一个`m x n`的矩阵`board`，由若干字符`'X'`和`'O'`，找到所有被`'X'`围绕的区域，并将这些区域里所有的`'O'`用`'X'`填充。

**示例1：**

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/19/xogrid.jpg">
</div>

```
输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。
```

**示例2：**

```
输入：board = [["X"]]
输出：[["X"]]
```

**提示：**

- `m` == `board.length`
- `n` == `board[i].length`
- 1 <= `m`, `n` <= 200
- `board[i][j]`为`'X'`或`'O'`

#### Solution

本题的BFS解法可参考如下。

[题目链接](https://leetcode.cn/problems/surrounded-regions/)：

```python
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """

        M = len(board)
        N = len(board[0])

        visited = [[0 for j in range(N)] for i in range(M)]

        def bfs(x: int, y: int) -> None:
            from collections import deque

            nonlocal visited

            visited[y][x] = 1

            queue = deque([(x, y)])

            while queue:
                x, y = queue.popleft()

                for dx, dy in [(0, 1), (0,-1), (1, 0), (-1, 0)]:
                    if 0 <= y+dy < M and 0 <= x+dx < N and board[y+dy][x+dx] == "O" and not visited[y+dy][x+dx]:
                        visited[y+dy][x+dx] = 1

                        queue.append((x+dx, y+dy))

        for y in range(M):
            if board[y][0] == "O":
                bfs(0, y)
            
            if board[y][N-1] == "O":
                bfs(N-1, y)
        
        for x in range(N):
            if board[0][x] == "O":
                bfs(x, 0)
            
            if board[M-1][x] == "O":
                bfs(x, M-1)
        
        for y in range(M):
            for x in range(N):
                if board[y][x] == "O" and not visited[y][x]:
                    board[y][x] = "X"
```
{: .snippet}

### 417. 太平洋大西洋水流问题

有一个`m × n`的矩形岛屿，与**太平洋**和**大西洋**相邻。**"太平洋"**处于大陆的左边界和上边界，而**"大西洋"**处于大陆的右边界和下边界。

这个岛被分割成一个由若干方形单元格组成的网格。给定一个`m x n`的整数矩阵`heights`，`heights[r][c]`表示坐标`(r, c)`上单元格**高于海平面的高度**。

岛上雨水较多，如果相邻单元格的高度**小于或等于**当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。

返回网格坐标`result`的**2D 列表**，其中`result[i] = [ri, ci]`表示雨水从单元格`(ri, ci)`流动**既可流向太平洋也可流向大西洋**。

**示例1：**

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg">
</div>

```
输入: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
输出: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
```

**示例2：**

```
输入: heights = [[2,1],[1,2]]
输出: [[0,0],[0,1],[1,0],[1,1]]
```

**提示：**

- `m` == `heights.length`
- `n` == `heights[r].length`
- 1 <= `m`, `n` <= 200
- 0 <= `heights[r][c]` <= 10⁵

#### Solution

本题的BFS实现可以参考如下。

[题目链接](https://leetcode.cn/problems/pacific-atlantic-water-flow/)：

```python
class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        M = len(heights)
        N = len(heights[0])

        visited = [[[0, 0] for j in range(N)] for i in range(M)]
        res = []

        def bfs(r: int, c: int, src: int) -> None:
            from collections import deque

            queue = deque([(r, c)])

            nonlocal visited

            visited[r][c][src] = 1

            while queue:
                r, c = queue.popleft()

                for dr, dc in [(0, 1), (0,-1), (1, 0), (-1, 0)]:
                    rr = r + dr
                    cc = c + dc

                    if 0 <= rr < M and 0 <= cc < N and heights[rr][cc] >= heights[r][c] and not visited[rr][cc][src]:
                        visited[rr][cc][src] = 1
                        queue.append((rr, cc))
            
        
        for r in range(M):
            visited[r][0][0] = 1
            visited[r][N-1][1] = 1

            bfs(r, 0, 0)
            bfs(r, N-1, 1)
        
        for c in range(N):
            visited[0][c][0] = 1
            visited[M-1][c][1] = 1

            bfs(0, c, 0)
            bfs(M-1, c, 1)
        
        for r in range(M):
            for c in range(N):
                if visited[r][c][0] and visited[r][c][1]:
                    res.append([r, c])
        
        return res
```
{: .snippet}

### 127. 单词接龙

字典`wordList`中从单词`beginWord`和`endWord`的**转换序列**是一个按下述规格形成的序列`beginWord -> s1 -> s2 -> ... -> sk`：

- 每一对相邻的单词只差一个字母。
- 对于1 <= `i` <= `k`时，每个`sᵢ`都在`wordList`中。注意，`beginWord`不需要在`wordList`中。
- `sₖ` == `endWord`。

给你两个单词`beginWord`和`endWord`和一个字典`wordList`，返回从`beginWord`到`endWord`的**最短转换序列**中的**单词数目**。如果不存在这样的转换序列，返回`0`。

**示例1：**

```
输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
输出：5
解释：一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog", 返回它的长度 5。
```

**示例2：**

```
输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
输出：0
解释：endWord "cog" 不在字典中，所以无法进行转换。
```

**提示：**

- 1 <= `beginWord.length` <= 10
- `endWord.length` == `beginWord.length`
- 1 <= `wordList.length` <= 5000
- `wordList[i].length` == `beginWord.length`
- `beginWord`、`endWord`和`wordList[i]`由小写英文字母组成
- `beginWord` != `endWord`
- `wordList`中的所有字符串**互不相同**

#### Solution

本题的解法在于把每个单词当做图中的节点，如果两个单词之间只相差一个字母则为这一对节点添加一条边，这样题目就转换为从`beginWord`节点出发寻找到达`endWord`的一条最短路径。需要注意这种最短路径问题**只能使用BFS**而不能使用DFS进行求解，代码框架如下：

```python
visited = {word: 0 for word in wordList}
visited[beginWord] = 1
queue = deque([beginWord])

while queue:
    word = queue.popleft()

    if word == endWord:
        return visited[word]
    
    for newWord in adj(word):
        if not visited[newWord]:
            visited[newWord] = visited[word] + 1
            queue.append(newWord)
```

在编程时还有一些细节需要考虑：

- 如果在BFS之前先利用单词之间的差异进行建图容易出现超时的问题，因此更加合理的策略是在搜索相邻节点时再考虑单词之间的差异。
- 直接使用`wordList`进行查找的复杂度是`O(n)`，因此更高效的查找方式是先把`wordList`转换为`set`或者`dict`，这样查找的复杂度可以降到`O(1)`。

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode-cn.com/solution-static/127/1.png" width="70%">
</div>

[题目链接](https://leetcode.cn/problems/word-ladder/)：

```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        from collections import deque

        wordSet = set(wordList)
        
        visited = {word: 0 for word in wordList}
        visited[beginWord] = 1
        queue = deque([beginWord])

        while queue:
            word = queue.popleft()

            if word == endWord:
                return visited[word]

            for i in range(len(word)):
                ww = list(word)
                for j in range(26):
                    ww[i] = chr(ord('a')+j)
                    newWord = "".join(ww)
                    
                    if newWord in wordSet and not visited[newWord]:
                        visited[newWord] = visited[word] + 1
                        queue.append(newWord)
        
        return 0
```
{: .snippet}