---
layout: article
title: 图论
key: leetcode-12
clipboard: true
aside:
  toc: true
sidebar:
  nav: LeetCode
---

## DFS

**深度优先搜索(DFS)**是对图进行遍历的基本方法，它等同于前面介绍过的[回溯](/leetcode/2023-03-04-Backtracking.html)。因此DFS算法的基本框架可参考回溯模板如下。

```
def dfs(节点，参数):
    if 终止条件:
        存放结果
        return
    
    for (选择：与节点相邻的其它节点):
        处理节点
        dfs(选择的节点)
        回溯(撤销对节点的处理)
```

### 797. 所有可能的路径

给你一个有`n`个节点的**有向无环图(DAG)**，请你找出所有从节点`0`到节点`n-1`的路径并输出(不要求按特定顺序)。

`graph[i]`是一个从节点`i`可以访问的所有节点的列表(即从节点`i`到节点`graph[i][j]`存在一条有向边)。

**示例1：**

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/09/28/all_1.jpg">
</div>

```
输入：graph = [[1,2],[3],[3],[]]
输出：[[0,1,3],[0,2,3]]
解释：有两条路径 0 -> 1 -> 3 和 0 -> 2 -> 3
```

**示例2：**

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/09/28/all_2.jpg">
</div>

```
输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]
输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]
```

**提示：**

- `n` == `graph.length`
- 2 <= `n` <= 15
- 0 <= `graph[i][j]` < `n`
- `graph[i][j]` != `i` (即不存在自环)
- `graph[i]`中的所有元素**互不相同**
- 保证输入为**有向无环图(DAG)**

#### Solution

本题需要使用DFS来遍历起点`0`到终点`n-1`的所有路径，当到达终点`n-1`时将路径`path`添加到结果`res`中即可。

[题目链接](https://leetcode.cn/problems/all-paths-from-source-to-target/)：

```python
class Solution:
    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
        N = len(graph)

        path = [0]
        res = []

        def dfs(node: int) -> None:
            nonlocal path, res
            
            if node == N-1:
                res.append(path[:])
                return
            
            for v in graph[node]:
                path.append(v)
                dfs(v)
                path.pop()
        
        dfs(0)

        return res
```
{: .snippet}

## BFS