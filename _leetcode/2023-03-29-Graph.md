---
layout: article
title: 图论
key: leetcode-12
clipboard: true
aside:
  toc: true
sidebar:
  nav: LeetCode
---

## DFS

**深度优先搜索(DFS)**是对图进行遍历的基本方法，它等同于前面介绍过的[回溯](/leetcode/2023-03-04-Backtracking.html)。因此DFS算法的基本框架可参考回溯模板如下。

```
def dfs(节点，参数):
    if 终止条件:
        存放结果
        return
    
    for (选择：与节点相邻的其它节点):
        处理节点
        dfs(选择的节点)
        回溯(撤销对节点的处理)
```

### 797. 所有可能的路径

给你一个有`n`个节点的**有向无环图(DAG)**，请你找出所有从节点`0`到节点`n-1`的路径并输出(不要求按特定顺序)。

`graph[i]`是一个从节点`i`可以访问的所有节点的列表(即从节点`i`到节点`graph[i][j]`存在一条有向边)。

**示例1：**

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/09/28/all_1.jpg">
</div>

```
输入：graph = [[1,2],[3],[3],[]]
输出：[[0,1,3],[0,2,3]]
解释：有两条路径 0 -> 1 -> 3 和 0 -> 2 -> 3
```

**示例2：**

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2020/09/28/all_2.jpg">
</div>

```
输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]
输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]
```

**提示：**

- `n` == `graph.length`
- 2 <= `n` <= 15
- 0 <= `graph[i][j]` < `n`
- `graph[i][j]` != `i` (即不存在自环)
- `graph[i]`中的所有元素**互不相同**
- 保证输入为**有向无环图(DAG)**

#### Solution

本题需要使用DFS来遍历起点`0`到终点`n-1`的所有路径，当到达终点`n-1`时将路径`path`添加到结果`res`中即可。

[题目链接](https://leetcode.cn/problems/all-paths-from-source-to-target/)：

```python
class Solution:
    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
        N = len(graph)

        path = [0]
        res = []

        def dfs(node: int) -> None:
            nonlocal path, res
            
            if node == N-1:
                res.append(path[:])
                return
            
            for v in graph[node]:
                path.append(v)
                dfs(v)
                path.pop()
        
        dfs(0)

        return res
```
{: .snippet}

### 200. 岛屿数量

给你一个由`'1'`(陆地)和`'0'`(水)组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

**提示：**

- `m` == `grid.length`
- `n` == `grid[i].length`
- 1 <= `m`, `n` <= 300
- `grid[i][j]`的值为`'0'`或`'1'`

#### Solution

本题的解法在于对整个地图进行遍历，每遇到一个岛屿就对所有和它相连的陆地进行标记并令岛屿记数`res`加`1`。本题的DFS解法可参考如下。

[题目链接](https://leetcode.cn/problems/number-of-islands/)：

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        H = len(grid)
        W = len(grid[0])

        visited = [[0 for j in range(W)] for i in range(H)]
        res = 0

        def dfs(x: int, y: int) -> None:
            nonlocal visited

            visited[y][x] = 1
            
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                if 0 <= x+dx < W and 0 <= y+dy < H and grid[y+dy][x+dx] == '1' and not visited[y+dy][x+dx]:
                    dfs(x+dx, y+dy)
        
        for y in range(H):
            for x in range(W):
                if grid[y][x] == '1' and not visited[y][x]:
                    dfs(x, y)
                    res += 1
            
        return res
```
{: .snippet}

### 695. 岛屿的最大面积

给你一个大小为`m x n`的二进制矩阵`grid`。

**岛屿**是由一些相邻的`1`(代表土地)构成的组合，这里的「相邻」要求两个`1`必须在**水平或者竖直的四个方向上**相邻。你可以假设`grid`的四个边缘都被`0`(代表水)包围着。

岛屿的面积是岛上值为`1`的单元格的数目。

计算并返回`grid`中最大的岛屿面积。如果没有岛屿，则返回面积为`0`。

**示例1：**

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg"  width="70%">
</div>

```
输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
输出：6
解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。
```

**示例2：**

```
输入：grid = [[0,0,0,0,0,0,0,0]]
输出：0
```

**提示：**

- `m` == `grid.length`
- `n` == `grid[i].length`
- 1 <= `m`, `n` <= 50
- `grid[i][j]`的值为`0`或`1`

#### Solution

本题的解法类似于[岛屿数量](/leetcode/2023-03-29-Graph.html#200-岛屿数量)，不过在DFS过程中需要把当前岛屿的面积记录在变量`A`中并且对所有的岛屿面积取最大值。

[题目链接](https://leetcode.cn/problems/max-area-of-island/)：

```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        M = len(grid)
        N = len(grid[0])

        visited = [[0 for j in range(N)] for i in range(M)]
        res = A = 0

        def dfs(x: int, y: int) -> None:
            nonlocal visited, A

            visited[y][x] = 1
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                if 0 <= y+dy < M and 0 <= x+dx < N and grid[y+dy][x+dx] and not visited[y+dy][x+dx]:
                    A += 1
                    dfs(x+dx, y+dy)
            
        
        for y in range(M):
            for x in range(N):
                if grid[y][x] and not visited[y][x]:
                    A = 1
                    dfs(x, y)
                    res = max(res, A)
        
        return res
```
{: .snippet}

### 1020. 飞地的数量

给你一个大小为`m x n`的二进制矩阵`grid`，其中`0`表示一个海洋单元格、`1`表示一个陆地单元格。

一次**移动**是指从一个陆地单元格走到另一个相邻(**上**、**下**、**左**、**右**)的陆地单元格或跨过`grid`的边界。

返回网格中**无法**在任意次数的移动中离开网格边界的陆地单元格的数量。

**示例1：**

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/18/enclaves1.jpg">
</div>

```
输入：grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
输出：3
解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。
```

**示例2：**

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/18/enclaves2.jpg">
</div>

```
输入：grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
输出：0
解释：所有 1 都在边界上或可以到达边界。
```

**提示：**

- `m` == `grid.length`
- `n` == `grid[i].length`
- 1 <= `m`, `n` <= 500
- `grid[i][j]`的值为`0`或`1`

#### Solution

本题的难点在于如何判断一块岛屿是否是飞地。实际上我们可以先从`grid`的四条边出发把所有和边相连的岛屿(绿色)都修改成海洋，这样`grid`剩余的岛屿(黄色)就都是飞地了。本题的DFS解法可参考如下。

<div align=center>
<img src="https://images.weserv.nl/?url=i.imgur.com/PBqOhHS.png"  width="70%">
</div>

[题目链接](https://leetcode.cn/problems/number-of-enclaves/)：

```python
class Solution:
    def numEnclaves(self, grid: List[List[int]]) -> int:
        M = len(grid)
        N = len(grid[0])

        res = 0

        def dfs(x: int, y: int) -> None:
            nonlocal grid, res

            grid[y][x] = 0
            res += 1

            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                if 0 <= y+dy < M and 0 <= x+dx < N and grid[y+dy][x+dx]:
                    dfs(x+dx, y+dy)
        
        for y in range(M):
            if grid[y][0]:
                dfs(0, y)
            if grid[y][N-1]:
                dfs(N-1, y)
        
        for x in range(N):
            if grid[0][x]:
                dfs(x, 0)
            if grid[M-1][x]:
                dfs(x, M-1)
        
        res = 0
        for y in range(M):
            for x in range(N):
                if grid[y][x]:
                    dfs(x, y)

        return res
```
{: .snippet}

### 130. 被围绕的区域

给你一个`m x n`的矩阵`board`，由若干字符`'X'`和`'O'`，找到所有被`'X'`围绕的区域，并将这些区域里所有的`'O'`用`'X'`填充。

**示例1：**

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/19/xogrid.jpg">
</div>

```
输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。
```

**示例2：**

```
输入：board = [["X"]]
输出：[["X"]]
```

#### Solution

本题的解法类似于[飞地的数量](/leetcode/2023-03-29-Graph.html#1020-飞地的数量)。我们只需要先标记`board`中与边界相连的岛屿，然后对`board`进行遍历把所有未标记过的岛屿到填充为`'X'`即可。本题的DFS解法可参考如下。

[题目链接](https://leetcode.cn/problems/surrounded-regions/)：

```python
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """

        M = len(board)
        N = len(board[0])

        visited = [[0 for j in range(N)] for i in range(M)]

        def dfs(x: int, y: int) -> None:
            nonlocal visited

            visited[y][x] = 1
            
            for dx, dy in [(0, 1), (0,-1), (1, 0), (-1, 0)]:
                if 0 <= y+dy < M and 0 <= x+dx < N and board[y+dy][x+dx] == "O" and not visited[y+dy][x+dx]:
                    dfs(x+dx, y+dy)
        
        for y in range(M):
            if board[y][0] == "O":
                dfs(0, y)
            
            if board[y][N-1] == "O":
                dfs(N-1, y)
        
        for x in range(N):
            if board[0][x] == "O":
                dfs(x, 0)
            
            if board[M-1][x] == "O":
                dfs(x, M-1)
        
        for y in range(M):
            for x in range(N):
                if board[y][x] == "O" and not visited[y][x]:
                    board[y][x] = "X"
```
{: .snippet}

## BFS

**广度优先搜索(BFS)**的实现类似于[层序遍历](/leetcode/2023-02-03-BinaryTree.html#102-二叉树的层序遍历)。在BFS中我们需要使用一个队列来依次保存需要拓展的节点，当队列非空时弹出新的节点进行拓展。

### 200. 岛屿数量

给你一个由`'1'`(陆地)和`'0'`(水)组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

**提示：**

- `m` == `grid.length`
- `n` == `grid[i].length`
- 1 <= `m`, `n` <= 300
- `grid[i][j]`的值为`'0'`或`'1'`

#### Solution

本题的BFS解法可参考如下。需要注意的是BFS在实现时每当有节点**入队**就将其标记为`visited`，否则会出现很多节点多次加入队列的情况从而导致超时。

[题目链接](https://leetcode.cn/problems/number-of-islands/)：

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        H = len(grid)
        W = len(grid[0])

        visited = [[0 for j in range(W)] for i in range(H)]
        res = 0

        def bfs(x: int, y: int) -> None:
            from collections import deque

            nonlocal visited
            
            visited[y][x] = 1
            queue = deque([(x, y)])

            while queue:
                x, y = queue.popleft()
            
                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    if 0 <= x+dx < W and 0 <= y+dy < H and grid[y+dy][x+dx] == '1' and not visited[y+dy][x+dx]:
                        queue.append((x+dx, y+dy))
                        visited[y+dy][x+dx] = 1
        
        for y in range(H):
            for x in range(W):
                if grid[y][x] == '1' and not visited[y][x]:
                    bfs(x, y)
                    res += 1
            
        return res
```
{: .snippet}

### 695. 岛屿的最大面积

给你一个大小为`m x n`的二进制矩阵`grid`。

**岛屿**是由一些相邻的`1`(代表土地)构成的组合，这里的「相邻」要求两个`1`必须在**水平或者竖直的四个方向上**相邻。你可以假设`grid`的四个边缘都被`0`(代表水)包围着。

岛屿的面积是岛上值为`1`的单元格的数目。

计算并返回`grid`中最大的岛屿面积。如果没有岛屿，则返回面积为`0`。

**示例1：**

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg" width="70%">
</div>

```
输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
输出：6
解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。
```

**示例2：**

```
输入：grid = [[0,0,0,0,0,0,0,0]]
输出：0
```

**提示：**

- `m` == `grid.length`
- `n` == `grid[i].length`
- 1 <= `m`, `n` <= 50
- `grid[i][j]`的值为`0`或`1`

#### Solution

本题的解法类似于[岛屿数量](/leetcode/2023-03-29-Graph.html#200-岛屿数量-1)，不过在BFS过程中需要把当前岛屿的面积记录在变量`A`中并且对所有的岛屿面积取最大值。

[题目链接](https://leetcode.cn/problems/max-area-of-island/)：

```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        M = len(grid)
        N = len(grid[0])

        visited = [[0 for j in range(N)] for i in range(M)]
        res = 0

        def bfs(x: int, y: int) -> int:
            from collections import deque

            queue = deque([(x, y)])
            A = 1

            nonlocal visited
            visited[y][x] = 1

            while queue:
                x, y = queue.popleft()

                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    if 0 <= y+dy < M and 0 <= x+dx < N and grid[y+dy][x+dx] and not visited[y+dy][x+dx]:
                        queue.append((x+dx, y+dy))
                        visited[y+dy][x+dx] = 1

                        A += 1
            
            return A     
        
        for y in range(M):
            for x in range(N):
                if grid[y][x] and not visited[y][x]:
                    A = bfs(x, y)
                    res = max(res, A)
        
        return res
```
{: .snippet}

### 1020. 飞地的数量

给你一个大小为`m x n`的二进制矩阵`grid`，其中`0`表示一个海洋单元格、`1`表示一个陆地单元格。

一次**移动**是指从一个陆地单元格走到另一个相邻(**上**、**下**、**左**、**右**)的陆地单元格或跨过`grid`的边界。

返回网格中**无法**在任意次数的移动中离开网格边界的陆地单元格的数量。

**示例1：**

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/18/enclaves1.jpg">
</div>

```
输入：grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
输出：3
解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。
```

**示例2：**

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/18/enclaves2.jpg">
</div>

```
输入：grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
输出：0
解释：所有 1 都在边界上或可以到达边界。
```

**提示：**

- `m` == `grid.length`
- `n` == `grid[i].length`
- 1 <= `m`, `n` <= 500
- `grid[i][j]`的值为`0`或`1`

#### Solution

本题的BFS解法可参考如下。

[题目链接](https://leetcode.cn/problems/number-of-enclaves/)：

```python
class Solution:
    def numEnclaves(self, grid: List[List[int]]) -> int:
        M = len(grid)
        N = len(grid[0])

        res = 0

        def bfs(x: int, y: int) -> None:
            from collections import deque

            nonlocal grid, res

            queue = deque([(x, y)])
            grid[y][x] = 0
            res += 1

            while queue:
                x, y = queue.popleft()

                for dx, dy in [(0, 1), (0,-1), (1, 0), (-1, 0)]:
                    if 0 <= y+dy < M and 0 <= x+dx < N and grid[y+dy][x+dx]:
                        queue.append((x+dx, y+dy))
                        
                        grid[y+dy][x+dx] = 0
                        res += 1
        
        for y in range(M):
            if grid[y][0]:
                bfs(0, y)
            
            if grid[y][N-1]:
                bfs(N-1, y)
        
        for x in range(N):
            if grid[0][x]:
                bfs(x, 0)
            
            if grid[M-1][x]:
                bfs(x, M-1)
        
        res = 0
        for y in range(M):
            for x in range(N):
                if grid[y][x]:
                    bfs(x, y)
            
        return res
```
{: .snippet}

### 130. 被围绕的区域

给你一个`m x n`的矩阵`board`，由若干字符`'X'`和`'O'`，找到所有被`'X'`围绕的区域，并将这些区域里所有的`'O'`用`'X'`填充。

**示例1：**

<div align=center>
<img src="https://images.weserv.nl/?url=assets.leetcode.com/uploads/2021/02/19/xogrid.jpg">
</div>

```
输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。
```

**示例2：**

```
输入：board = [["X"]]
输出：[["X"]]
```

#### Solution

本题的BFS解法可参考如下。

[题目链接](https://leetcode.cn/problems/surrounded-regions/)：

```python
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """

        M = len(board)
        N = len(board[0])

        visited = [[0 for j in range(N)] for i in range(M)]

        def bfs(x: int, y: int) -> None:
            from collections import deque

            nonlocal visited

            visited[y][x] = 1

            queue = deque([(x, y)])

            while queue:
                x, y = queue.popleft()

                for dx, dy in [(0, 1), (0,-1), (1, 0), (-1, 0)]:
                    if 0 <= y+dy < M and 0 <= x+dx < N and board[y+dy][x+dx] == "O" and not visited[y+dy][x+dx]:
                        visited[y+dy][x+dx] = 1

                        queue.append((x+dx, y+dy))

        for y in range(M):
            if board[y][0] == "O":
                bfs(0, y)
            
            if board[y][N-1] == "O":
                bfs(N-1, y)
        
        for x in range(N):
            if board[0][x] == "O":
                bfs(x, 0)
            
            if board[M-1][x] == "O":
                bfs(x, M-1)
        
        for y in range(M):
            for x in range(N):
                if board[y][x] == "O" and not visited[y][x]:
                    board[y][x] = "X"
```
{: .snippet}