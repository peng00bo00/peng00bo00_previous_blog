---
layout: article
title: 字符串
key: leetcode-04
clipboard: true
aside:
  toc: true
sidebar:
  nav: LeetCode
---

## 翻转

### 344. 反转字符串

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组`s`的形式给出。

不要给另外的数组分配额外的空间，你必须**原地修改输入数组**、使用`O(1)`的额外空间解决这一问题。

**示例1：**

```
输入：s = ["h","e","l","l","o"]
输出：["o","l","l","e","h"]
```

**示例2：**

```
输入：s = ["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```

**提示：**

- 1 <= `s.length` <= 10⁵
- `s[i]`都是ASCII码表中的可打印字符

#### Solution

本题比较简单，只需要使用双指针交换`s`中的元素即可。

<div align=center>
<img src="https://search.pstatic.net/common?src=https://i.imgur.com/jFBlRm8.gif">
</div>

[题目链接](https://leetcode.cn/problems/reverse-string/)：

```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """

        left, right = 0, len(s)-1

        while left < right:
            s[left], s[right] = s[right], s[left]

            left += 1
            right-= 1
```
{: .snippet}

### 541. 反转字符串 II

给定一个字符串`s`和一个整数`k`，从字符串开头算起，每计数至`2k`个字符，就反转这`2k`字符中的前`k`个字符。

- 如果剩余字符少于`k`个，则将剩余字符全部反转。
- 如果剩余字符小于`2k`但大于或等于`k`个，则反转前`k`个字符，其余字符保持原样。

**示例1：**

```
输入：s = "abcdefg", k = 2
输出："bacdfeg"
```

**示例2：**

```
输入：s = "abcd", k = 2
输出："bacd"
```

**提示：**

- 1 <= `s.length` <= 10⁴
- `s`仅由小写英文组成
- 1 <= k <= 10⁴

#### Solution

本题与[反转字符串](/leetcode/2023-01-23-String.html#344-反转字符串)基本一致，只需要在遍历时每次取大小为`2*k`的窗口并反转其中的前`k`个元素即可。不过需要注意python中字符串是**不可变对象(immutable)**无法直接进行修改，我们必须先将`s`转换为列表进行反转，然后将反转后的列表转换为字符串输出。

[题目链接](https://leetcode.cn/problems/reverse-string-ii/)：

```python
class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        ss = list(s)
        N = len(ss)

        for i in range(0, N, 2*k):
            ss[i:i+k] = ss[i:i+k][::-1]

        return "".join(ss)
```
{: .snippet}

### 151. 反转字符串中的单词

给你一个字符串`s`，请你反转字符串中**单词**的顺序。

**单词**是由非空格字符组成的字符串。`s`中使用至少一个空格将字符串中的**单词**分隔开。

返回**单词**顺序颠倒且**单词**之间用单个空格连接的结果字符串。

注意：输入字符串`s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

**示例1：**

```
输入：s = "the sky is blue"
输出："blue is sky the"
```

**示例2：**

```
输入：s = "  hello world  "
输出："world hello"
解释：反转后的字符串中不能存在前导空格和尾随空格。
```

**示例3：**

```
输入：s = "a good   example"
输出："example good a"
解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。
```

**提示：**

- 1 <= `s.length` <= 10⁴
- `s`包含英文大小写字母、数字和空格`' '`
- `s`中**至少存在一个**单词

#### Solution

本题的解法可以分为3步：

1. 去掉字符串中多余的空格`' '`
2. 将整个字符串反转
3. 将字符串中的每个单词反转

<div align=center>
<img src="https://images.weserv.nl/?url=i.imgur.com/pUyeqZU.png" width="80%">
</div>

为了去除掉字符串中多余的空格，这里定义一个辅助函数`removeExtraSpace()`通过双指针来进行遍历：

1. 使用`left`指针去掉字符串开头的空格
2. 使用`right`指针去掉字符串末尾的空格
3. 对字符串中间部分进行遍历，如果遇到非空格则把字符加入到`res`中否则继续前进直到遇到下一个非空格字符

`removeExtraSpace()`代码可参考如下。

```python
def removeExtraSpace(s: List[str]) -> List[str]:
    left, right = 0, len(s)-1

    while s[left] == " ":
        left += 1
    
    while s[right] == " ":
        right -= 1
    
    res = []

    while left <= right:
        if s[left] != " ":
            res.append(s[left])
            left += 1
        else:
            while s[left] == " ":
                left += 1

            res.append(" ")

    return res
```

除了`removeExtraSpace()`之外我们再定义一个辅助函数`reverse()`用来反转指定区间内的字符，代码可参考如下：

```python
def reverse(s: List[str], left: int, right: int) -> List[str]:
    while left < right:
        s[left], s[right] = s[right], s[left]

        left += 1
        right-= 1
    
    return s
```

这样在第二步反转整个字符串中我们只需要指定`left = 0`以及`right = len(ss)-1`即可。

而在第三步我们需要将空格分割的单词分别进行反转。为了方便处理，我们在整体反转的字符串`ss`后面添加一个空格，这样所有的单词都是以空格结尾。然后利用双指针`left`指向每个单词开头，`right`指向单词结尾的空格进行反转即可。

```python
## reverse each word
left = right = 0
for right in range(len(ss)):
    if ss[right] == " ":
        ss = reverse(ss, left, right)
        left = right + 1
```

最后需要注意的是反转每个单词后`ss`会以之前添加的空格作为开头，我们需要手动去掉它。整个流程的代码可以参考如下。

[题目链接](https://leetcode.cn/problems/reverse-words-in-a-string/)：

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        def removeExtraSpace(s: List[str]) -> List[str]:
            left, right = 0, len(s)-1

            while s[left] == " ":
                left += 1
            
            while s[right] == " ":
                right -= 1
            
            res = []

            while left <= right:
                if s[left] != " ":
                    res.append(s[left])
                    left += 1
                else:
                    while s[left] == " ":
                        left += 1

                    res.append(" ")

            return res
        
        def reverse(s: List[str], left: int, right: int) -> List[str]:
            while left < right:
                s[left], s[right] = s[right], s[left]

                left += 1
                right-= 1
            
            return s
        
        ss = list(s)
        
        ## remove extra space
        ss = removeExtraSpace(ss)

        ## reverse whole list
        ss = reverse(ss, 0, len(ss)-1)

        ## add an additional " " in the end
        ss.append(" ")

        ## reverse each word
        left = right = 0
        for right in range(len(ss)):
            if ss[right] == " ":
                ss = reverse(ss, left, right)
                left = right + 1
        
        ## remove the additional " " in the beginning
        ss = ss[1:]

        return "".join(ss)
```
{: .snippet}

当然如果允许使用库函数的话可以直接利用`s.split(" ")`对字符串进行分割，然后再对分割后的每个单词进行反转并组合成新的字符串输出即可。

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        return " ".join(reversed(s.split()))
```
{: .snippet}

### 剑指Offer 58-II.左旋转字符串

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

**示例1：**

```
输入: s = "abcdefg", k = 2
输出: "cdefgab"
```

**示例2：**

```
输入: s = "lrloseumgh", k = 6
输出: "umghlrlose"
```

**限制：**

- 1 <= `k` < `s.length` <= 10000

#### Solution

本题解法类似于[轮转数组](/leetcode/2023-01-02-Array.html#189-轮转数组)。我们需要先反转前`n`个字符以及末尾的`N-n`个字符，最后反转整个字符串即可。

<div align=center>
<img src="https://images.weserv.nl/?url=i.imgur.com/KfhLlNs.png" width="60%">
</div>

[题目链接](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)：

```python
class Solution:
    def reverseLeftWords(self, s: str, n: int) -> str:
        def reverse(s: List[str], left: int, right: int) -> List[str]:
            while left < right:
                s[left], s[right] = s[right], s[left]

                left += 1
                right-= 1
            
            return s
        
        ss = list(s)
        N  = len(ss)

        ss = reverse(ss, 0, n-1)
        ss = reverse(ss, n, N-1)
        ss = reverse(ss, 0, N-1)

        return "".join(ss)
```
{: .snippet}

当然本题也可以直接通过对字符串进行索引和拼接来实现。

```python
class Solution:
    def reverseLeftWords(self, s: str, n: int) -> str:
        return s[n:] + s[:n]
```
{: .snippet}

### 7. 整数反转

给你一个32位的有符号整数`x` ，返回将`x`中的数字部分反转后的结果。

如果反转后整数超过32位的有符号整数的范围`[−2³¹,  2³¹ − 1]`，就返回`0`。

**假设环境不允许存储64位整数(有符号或无符号)。**

**示例1：**

```
输入：x = 123
输出：321
```

**示例2：**

```
输入：x = -123
输出：-321
```

**示例3：**

```
输入：x = 120
输出：21
```

**示例4：**

```
输入：x = 0
输出：0
```

**提示：**

- -2³¹ <= `x` <= 2³¹ - 1

#### Solution

本题的难点在于如何考虑32位整数的范围以及负数的情况。假设`x > 0`且反转后不会出现溢出的问题，我们只需要不断取出`x`的末位数字并放到`res`的末尾即可。

<div align=center>
<img src="https://images.weserv.nl/?url=i.imgur.com/BA2jINi.png" width="70%">
</div>

接下来考虑32位数字溢出的问题。记32位整数的上下界分别为`INT_MIN = -(1 << 31)`与`INT_MAX = (1 << 31) - 1`，如果`res < INT_MIN // 10 + 1`或`res > INT_MAX // 10`时会出现溢出，因此需要在更新`res`前进行判断。

最后是负数的情况。这里需要注意的是python中取模和取余运算对于负数与其它常见编程语言不同，`digit = x % 10`在`x < 0`的情况下会返回`[0, 9)`，因此我们需要令`digit -= 10`才能得到所需的末位数字。

[题目链接](https://leetcode.cn/problems/reverse-integer/)：

```python
class Solution:
    def reverse(self, x: int) -> int:        
        INT_MIN, INT_MAX = -(1 << 31), (1 << 31) - 1

        res = 0
        while x:
            if res < INT_MIN // 10 + 1 or res > INT_MAX // 10:
                return 0
            
            digit = x % 10
            if x < 0 and digit > 0:
                digit -= 10

            x = (x - digit) // 10
            res = res * 10 + digit

        return res
```
{: .snippet}

## 替换字符

### 剑指Offer 05.替换空格

请实现一个函数，把字符串`s`中的每个空格替换成"%20"。

**示例1：**

```
输入：s = "We are happy."
输出："We%20are%20happy."
```

**限制：**

- 0 <= `s` 的长度 <= 10000

#### Solution

本题的解法在于从后向前对字符串进行遍历。当`s[i] == " "`时，字符串`s`会被分割为未遍历的`s[:i]`以及完成空格替换的`s[i+1:]`两部分，此时我们可以更新字符串`s = s[:i] + "%20" + s[i+1:]`来完成对空格的替换。而继续遍历时`i`会向前指向未遍历的部分，这样就无需考虑`s`更新后改变的长度。

[题目链接](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)：

```python
class Solution:
    def replaceSpace(self, s: str) -> str:
        N = len(s)

        for i in range(N-1, -1, -1):
            if s[i] == " ":
                s = s[:i] + "%20" + s[i+1:]
        
        return s
```
{: .snippet}

当然本题也可以使用字符串的内置函数来进行处理。

```python
class Solution:
    def replaceSpace(self, s: str) -> str:        
        return "%20".join(s.split(" "))
```
{: .snippet}

## KMP

### 28. 找出字符串中第一个匹配项的下标

给你两个字符串`haystack`和`needle`，请你在`haystack`字符串中找出`needle`字符串的第一个匹配项的下标（下标从 0 开始）。如果`needle`不是`haystack`的一部分，则返回`-1` 。

**示例1：**

```
输入：haystack = "sadbutsad", needle = "sad"
输出：0
解释："sad" 在下标 0 和 6 处匹配。
第一个匹配项的下标是 0 ，所以返回 0 。
```

**示例2：**

```
输入：haystack = "leetcode", needle = "leeto"
输出：-1
解释："leeto" 没有在 "leetcode" 中出现，所以返回 -1 。
```

**提示：**

- 1 <= `haystack.length, needle.length` <= 10⁴
- `haystack`和`needle`仅由小写英文字符组成

#### Solution

[题目链接](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)：

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        def buildNEXT(pattern: str) -> List[int]:
            NEXT = [0 for _ in pattern]
            j = 0
            
            for i in range(1, len(pattern)):
                while j > 0 and pattern[i] != pattern[j]:
                    j = NEXT[j-1]

                if pattern[i] == pattern[j]:
                    j += 1
                
                NEXT[i] = j

            return NEXT

        NEXT = buildNEXT(needle)

        i, j = 0, 0
        while i < len(haystack):
            if haystack[i] == needle[j]:
                i += 1
                j += 1
            elif j > 0:
                j = NEXT[j-1]
            else:
                i += 1
            
            if j == len(needle):
                return i-j
        
        return -1
```
{: .snippet}

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        return haystack.find(needle)
```
{: .snippet}

### 459. 重复的子字符串

给定一个非空的字符串`s`，检查是否可以通过由它的一个子串重复多次构成。

**示例1：**

```
输入: s = "abab"
输出: true
解释: 可由子串 "ab" 重复两次构成。
```

**示例2：**

```
输入: s = "aba"
输出: false
```

**示例3：**

```
输入: s = "abcabcabcabc"
输出: true
解释: 可由子串 "abc" 重复四次构成。 (或子串 "abcabc" 重复两次构成。)
```

**提示：**

- 1 <= `s.length` <= 10⁴
- `s`由小写英文字母组成

#### Solution

[题目链接](https://leetcode.cn/problems/repeated-substring-pattern/)：

```python
class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:        
        def buildNEXT(pattern: str) -> List[int]:
            NEXT = [0 for _ in pattern]
            j = 0

            for i in range(1, len(pattern)):
                while j > 0 and pattern[i] != pattern[j]:
                    j = NEXT[j-1]
                
                if pattern[i] == pattern[j]:
                    j += 1
                
                NEXT[i] = j

            return NEXT
        
        NEXT = buildNEXT(s)
        
        if NEXT[-1] != 0 and len(s) % (len(s)-NEXT[-1]) == 0:
            return True
        
        return False
```
{: .snippet}


## 双指针

### 925. 长按键入

你的朋友正在使用键盘输入他的名字`name`。偶尔，在键入字符`c`时，按键可能会被长按，而字符可能被输入`1`次或多次。

你将会检查键盘输入的字符`typed`。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回`True`。

**示例1：**

```
输入：name = "alex", typed = "aaleex"
输出：true
解释：'alex' 中的 'a' 和 'e' 被长按。
```

**示例2：**

```
输入：name = "saeed", typed = "ssaaedd"
输出：false
解释：'e' 一定需要被键入两次，但在 typed 的输出中不是这样。
```

**提示：**

- 1 <= `name.length, typed.length` <= 1000
- `name`和`typed`的字符都是小写字母

#### Solution

本题需要使用双指针来逐位比较`name`和`typed`两个字符串。

- 如果`name[i] == typed[j]`则两个指针在当前位置的字符完成匹配，继续比较
- 如果`name[i] != typed[j]`则需要进一步考虑是否在`typed`中出现重复输入：
  - 如果`typed[j] == typed[j - 1]`说明发生了重复输入，此时需要继续移动`j`指针
  - 否则说明无法完成字符匹配，直接返回`False`
- 完成遍历后需要考虑`i`指针是否移动到`name`末尾：
  - 如果`i == len(name)`说明所有字符都匹配成功，返回`True`
  - 否则说明无法完成字符匹配，返回`False`

整个算法过程可以参考如下。

<div align=center>
<img src="https://search.pstatic.net/common?src=https://i.imgur.com/cVEK5AW.gif">
</div>

[题目链接](https://leetcode.cn/problems/long-pressed-name/)：

```python
class Solution:
    def isLongPressedName(self, name: str, typed: str) -> bool:
        i = j = 0
        m, n = len(name), len(typed)

        while j < n:
            if i < m and name[i] == typed[j]:
                i += 1
                j += 1
            elif j >= 1 and typed[j] == typed[j - 1]:
                j += 1
            else:
                return False
                
        return i == m
```
{: .snippet}

### 844. 比较含退格的字符串

同[844. 比较含退格的字符串](/leetcode/2023-01-02-Array.html#844-比较含退格的字符串)。

#### Solution

[题目链接](https://leetcode.cn/problems/backspace-string-compare/)：

```python
class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        def backspace(s: List[str]) -> List[str]:
            fast, slow = 0, 0
            for fast in range(len(s)):
                if s[fast] != "#":
                    s[slow] = s[fast]
                    slow += 1
                elif slow > 0:
                    slow -= 1
            
            return s[:slow]
        
        return backspace(list(s)) == backspace(list(t))
```
{: .snippet}

### 38. 外观数列

给定一个正整数`n`，输出外观数列的第`n`项。

「外观数列」是一个整数序列，从数字`1`开始，序列中的每一项都是对前一项的描述。

你可以将其视作是由递归公式定义的数字字符串序列：

- `countAndSay(1) = "1"`
- `countAndSay(n)`是对`countAndSay(n-1)`的描述，然后转换成另一个数字字符串。

前五项如下：

```
1.     1
2.     11
3.     21
4.     1211
5.     111221
第一项是数字 1 
描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"
描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"
描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"
描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"
```

要**描述**一个数字字符串，首先要将字符串分割为**最小**数量的组，每个组都由连续的最多**相同字符**组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。

例如，数字字符串`"3322251"`的描述如下图：

<div align=center>
<img src="https://images.weserv.nl/?url=pic.leetcode-cn.com/1629874763-TGmKUh-image.png">
</div>

**示例1：**

```
输入：n = 1
输出："1"
解释：这是一个基本样例。
```

**示例2：**

```
输入：n = 4
输出："1211"
解释：
countAndSay(1) = "1"
countAndSay(2) = 读 "1" = 一 个 1 = "11"
countAndSay(3) = 读 "11" = 二 个 1 = "21"
countAndSay(4) = 读 "21" = 一 个 2 + 一 个 1 = "12" + "11" = "1211"
```

**提示：**

- 1 <= `n` <= 30

#### Solution

本题需要使用到递归和双指针来进行处理。首先考虑递归部分，当`n == 1`时返回基本样例`"1"`，而在其它情况下则需要调用自身`countAndSay(n-1)`得到待描述的字符串`s`。

接下来使用双指针对`s`进行描述。这里利用快慢指针`fast`和`slow`维护具有相同字符的区间并用快指针`fast`进行遍历，当`s[fast] != s[slow]`时计算区间的长度并把`s[slow]`添加到`res`中，`res += str(fast-slow) + s[slow]`。需要注意的是`fast`完成遍历时要把末尾的区间也添加到`res`中，`res += str(fast-slow+1) + s[slow]`。整个算法流程可以参考如下。

[题目链接](https://leetcode.cn/problems/count-and-say/)：

```python
class Solution:
    def countAndSay(self, n: int) -> str:
        if n == 1:
            return "1"
        
        s = self.countAndSay(n-1)
        res = ""

        fast = slow = 0
        for fast in range(len(s)):
            if s[fast] != s[slow]:
                res += str(fast-slow) + s[slow]

                slow = fast
        
        res += str(fast-slow+1) + s[slow]

        return res
```
{: .snippet}

## Reference

- [LeetCode：344.反转字符串](https://www.bilibili.com/video/BV1fV4y17748/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)
- [LeetCode：541.反转字符串II](https://www.bilibili.com/video/BV1dT411j7NN/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)
- [LeetCode：151.翻转字符串里的单词](https://www.bilibili.com/video/BV1uT41177fX/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)
- [KMP算法(理论篇)](https://www.bilibili.com/video/BV1PD4y1o7nd/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)
- [KMP算法(代码篇)](https://www.bilibili.com/video/BV1M5411j7Xx/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)
- [最浅显易懂的 KMP 算法讲解](https://www.bilibili.com/video/BV1AY4y157yL/?spm_id_from=333.788.recommend_more_video.0&vd_source=7a2542c6c909b3ee1fab551277360826)
- [LeetCode：459.重复的子字符串](https://www.bilibili.com/video/BV1cg41127fw/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)