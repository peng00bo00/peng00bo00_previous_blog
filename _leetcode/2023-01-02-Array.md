---
layout: article
title: 数组
key: leetcode-01
clipboard: true
aside:
  toc: true
sidebar:
  nav: LeetCode
---

## 二分查找

当题干中出现了**有序数组**和**无重复元素**时就可以考虑使用二分查找来进行解题。二分查找的框架是定义一个搜索区间`[left, right]`，然后利用中间元素`mid`来不断更新区间：

```python
left, right = 0, len(arr)-1

while left <= right:
    mid = left + (right-left) // 2

    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        left = mid + 1
    else:
        right = mid - 1
```

需要注意的是在更新区间端点时要把`left`和`right`更新为`mid + 1`和`mid - 1`。这是因为我们已经检查过中点`mid`对应的元素一定不是目标`target`，也就无需再考虑`mid`位置。

### 704. 二分查找

给定一个`n`个元素有序的（升序）整型数组`nums`和一个目标值`target`，写一个函数搜索`nums`中的 `target`，如果目标值存在返回下标，否则返回`-1`。

**示例1：**

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例2：**

```
输入: nums = [-1,0,3,5,9,12], target = 2     
输出: -1        
解释: 2 不存在 nums 中因此返回 -1        
```

**提示：**

- 你可以假设`nums`中的所有元素是不重复的。
- `n`将在`[1, 10000]`之间。
- `nums`的每个元素都将在`[-9999, 9999]`之间。

#### Solution

[题目链接](https://leetcode.cn/problems/binary-search/)：

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums)-1

        while left <= right:
            mid = left + (right-left) // 2

            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1

        return -1
```
{: .snippet}

### 35. 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为`O(log n)`的算法。

**示例 1：**

```
输入: nums = [1,3,5,6], target = 5
输出: 2
```

**示例 2：**

```
输入: nums = [1,3,5,6], target = 2
输出: 1
```

**示例 3：**

```
输入: nums = [1,3,5,6], target = 7
输出: 4
```

**提示：**

- 1 <= `nums.length` <= 10<sup>4</sup>。
- -10<sup>4</sup> <= `nums[i]` <= 10<sup>4</sup>。
- `nums`为**无重复元素**的**升序**排列数组。
- -10<sup>4</sup> <= `target` <= 10<sup>4</sup>。

#### Solution

当`target`存在于`nums`数组中时使用标准的二分查找即可；而当`target`不在`nums`中时我们需要返回数组中首个大于`target`的元素位置，此时它即为退出搜索循环时`left`的位置。

[题目链接](https://leetcode.cn/problems/search-insert-position/)：

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums)-1
        
        while left <= right:
            mid = left + (right-left) // 2

            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        
        return left
```
{: .snippet}

### 34. 在排序数组中查找元素的第一个和最后一个位置

给你一个按照非递减顺序排列的整数数组`nums`，和一个目标值`target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值target，返回`[-1, -1]`。

你必须设计并实现时间复杂度为`O(log n)`的算法解决此问题。

**示例 1：**

```
输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
```

**示例 2：**

```
输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]
```

**示例 3：**

```
输入: nums = [], target = 0
输出: [-1,-1]
```

**提示：**

- 1 <= `nums.length` <= 10<sup>5</sup>。
- -10<sup>9</sup> <= `nums[i]` <= 10<sup>9</sup>。
- `nums`是一个非递减数组。
- -10<sup>9</sup> <= `target` <= 10<sup>9</sup>。

#### Solution

当数组中有重复的`target`时，使用二分查找会得到重复区间中的某个位置。此时为了得到重复区间的边界，只需分别向左右进行搜索即可。

[题目链接](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)：

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if len(nums) == 0:
            return [-1, -1]
        
        idx = self.binarySearch(nums, target)
        if idx == -1:
            return [-1, -1]

        left, right = idx, idx
        while left-1 >= 0 and nums[left-1] == target:
            left -= 1

        while right+1 <= len(nums)-1 and nums[right+1] == target:
            right += 1
        
        return [left, right]
    
    def binarySearch(self, nums: List[int], target: int) -> int:        
        left, right = 0, len(nums)-1

        while left <= right:
            mid = left + (right-left) // 2

            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        
        return -1
```
{: .snippet}

### 69. x的平方根

给你一个非负整数`x`，计算并返回`x`的**算术平方根**。

由于返回类型是整数，结果只保留**整数部分**，小数部分将被**舍去**。

注意：不允许使用任何内置指数函数和算符，例如`pow(x, 0.5)`或者`x ** 0.5`。

**示例 1：**

```
输入: x = 4
输出: 2
```

**示例 2：**

```
输入: x = 8
输出: 2
解释: 8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
```

**提示：**

- 0 <= `x` <= 2<sup>31</sup> - 1。

#### Solution

使用二分法进行解题时我们需要稍微修改一下判断条件，当中点`mid`的平方小于等于`x`且`mid+1`的平方大于`x`时退出搜索。

[题目链接](https://leetcode.cn/problems/sqrtx/)：

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        def cond(xx):
            if xx*xx <= x and (xx+1)*(xx+1) > x:
                return True
            return False
        
        left, right = 0, x
        while left <= right:
            mid = left + (right-left) // 2

            if cond(mid):
                return mid
            elif mid*mid < x:
                left = mid+1
            else:
                right = mid-1
        
        return mid
```
{: .snippet}

当然更快的解法是使用牛顿法，迭代式为：

$$
\begin{aligned}
y &\leftarrow y - \frac{y^2-x}{2y} \\
&\leftarrow \frac{y}{2} + \frac{x}{2y}
\end{aligned}
$$

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        y = x

        while y*y > x:
            y = y/2+x/(2*y)
            y = int(y)
        
        return y
```
{: .snippet}

### 367. 有效的完全平方数

给你一个正整数`num`。如果`num`是一个完全平方数，则返回`true`，否则返回`false`。

**完全平方数**是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。

不能使用任何内置的库函数，如`sqrt`。

**示例 1：**

```
输入: num = 16
输出: true
解释: 返回 true ，因为 4 * 4 = 16 且 4 是一个整数。
```

**示例 2：**

```
输入: num = 14
输出: false
解释: 返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。
```

**提示：**

- 1 <= `num` <= 2<sup>31</sup> - 1。

#### Solution

[题目链接](https://leetcode.cn/problems/valid-perfect-square/)：

```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        if num == 1:
            return True

        left, right = 1, num-1

        while left <= right:
            mid = left + (right-left) // 2
            mid2= mid*mid

            if mid2 == num:
                return True
            elif mid2 < num:
                left = mid + 1
            else:
                right = mid - 1
        
        return False
```
{: .snippet}

除了二分法之外，更快的方法是利用完全平方数的性质。实际上完全平方数可以表示为等差数列的和：

- 1×1 = 1
- 2×2 = 1 + 3
- 3×3 = 1 + 3 + 5
- 4×4 = 1 + 3 + 5 + 7
- ...
- n×n = 1 + 3 + ... + (2n-1)

因此我们只需要判断`num`是否能够分解为这样的等差数列即可。

```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        i = 1
        while num > 0:
            num -= i
            i += 2
        
        return num == 0
```
{: .snippet}

## 双指针

双指针的基本思想是使用两个指针来遍历数组，很多需要使用二重循环的问题通过双指针就只需一次循环就能解决，这样算法的复杂度就由`O(n²)`降低为`O(n)`。

### 27. 移除元素

给你一个数组`nums`和一个值`val`，你需要**原地**移除所有数值等于`val`的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用`O(1)`额外空间并**原地**修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**示例 1：**

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

**示例 2：**

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
```

**提示：**

- 0 <= `nums.length` <= 100。
- 0 <= `nums[i]` <= 50。
- 0 <= `val` <= 100。

#### Solution

这个问题可以使用快慢两个指针来进行处理：快指针`fast`直接对数组进行遍历，而慢指针`slow`则对应不包含`val`的新数组。当快指针`fast`遇到`val`时保持慢指针`slow`不动，这样可以保证新数组不会包含`val`；否则就把`fast`位置的值赋给`slow`，这样就更新了数组；最后慢指针`slow`的位置即为所需的新数组长度。整个算法过程可以可视化如下：

<div align=center>
<img src="https://camo.githubusercontent.com/a701d49e9f64bd71f08a19276679f49d971d765e07402b3982f9b0ab63969f45/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676e7472647336723539673330647530396d6e70642e676966" width="50%">
</div>

[题目链接](https://leetcode.cn/problems/remove-element/)：

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        fast, slow = 0, 0

        for fast in range(len(nums)):
            if nums[fast] != val:
                nums[slow] = nums[fast]
                slow += 1

        return slow
```
{: .snippet}

### 283. 移动零

给定一个数组`nums`，编写一个函数将所有`0`移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意**，必须在不复制数组的情况下原地对数组进行操作。

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2：**

```
输入: nums = [0]
输出: [0]
```

**提示：**

- 1 <= `nums.length` <= 10<sup>4</sup>。
- -2<sup>31</sup> <= `nums[i]` <= 2<sup>31</sup>-1。

#### Solution

解法与[27. 移除元素](https://peng00bo00.github.io/leetcode/2023-01-02-Array.html#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0)类似，同样使用快慢两个指针来对数组进行遍历。当快指针`fast`遇到`0`时保持慢指针不动，否则交换两个指针指向的元素并且移动慢指针`slow`。

[题目链接](https://leetcode.cn/problems/move-zeroes/)：

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """

        slow, fast = 0, 0

        for fast in range(len(nums)):
            if nums[fast] != 0:
                nums[slow], nums[fast] = nums[fast], nums[slow]
                slow += 1
```
{: .snippet}

### 844. 比较含退格的字符串

给定`s`和`t`两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回`true`。`#`代表退格字符。

**注意：**如果对空文本输入退格字符，文本继续为空。

**示例 1：**

```
输入：s = "ab#c", t = "ad#c"
输出：true
解释：s 和 t 都会变成 "ac"。
```

**示例 2：**

```
输入：s = "ab##", t = "c#d#"
输出：true
解释：s 和 t 都会变成 ""。
```

**示例 3：**

```
输入：s = "a#c", t = "b"
输出：false
解释：s 会变成 "c"，但 t 仍然是 "b"。
```

**提示：**

- 1 <= `s.length`, `t.length` <= 200。
- `s`和`t`只含有小写字母以及字符`#`。

#### Solution

利用双指针可以在`O(1)`的空间复杂度来解决这个题目。由于退格字符`#`不会影响到它后面的字符，我们可以从后向前对两个字符串进行遍历。具体来说我们使用`i`和`j`两个指针分别指向两个字符串的末尾，`skipI`和`skipJ`分别表示字符串中中遍历到的退格。算法整体思路如下：

1. 如果字符串中当前的字符为`#`则向前移动`i`或者`j`，对应的`skipI`和`skipJ`需要进行自增。
2. 如果字符串中当前的字符不是`#`，则根据`skipI`和`skipJ`是否为选择0继续向前移动或是停止。
3. 比较两个字符串当前的最末位`s[i]`和`t[j]`，如果不相等则返回`False`，否则回到第1步继续进行比较。

<div align=center>
<img src="https://camo.githubusercontent.com/7e8b6ba5fb7b3c53a9a8e1c882e4f7503b7a2cc303c422dffb4de51920dd9c0e/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f3834342ee6af94e8be83e590abe98080e6a0bce79a84e5ad97e7aca6e4b8b22e676966" width="50%">
</div>

[题目链接](https://leetcode.cn/problems/backspace-string-compare/)：

```python
class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        i, j = len(s)-1, len(t)-1
        skipI, skipJ = 0, 0

        while i >= 0 or j >= 0:
            ## back move i
            while i >= 0:
                if s[i] == "#":
                    i -= 1
                    skipI += 1
                else:
                    if skipI > 0:
                        i -= 1
                        skipI -= 1
                    else:
                        break
            
            ## back move j
            while j >= 0:
                if t[j] == "#":
                    j -= 1
                    skipJ += 1
                else:
                    if skipJ > 0:
                        j -= 1
                        skipJ -= 1
                    else:
                        break
            
            if i >= 0 and j >= 0:
                if s[i] != t[j]:
                    return False
            elif i >= 0 or j >= 0:
                return False
            
            i -= 1
            j -= 1
        
        return True
```
{: .snippet}

除此之外，也可以利用快慢指针来模拟字符串的退格过程。当快指针`fast`遇到非`#`字符时将它指向的元素赋给慢指针`slow`，然后将慢指针右移；否则将慢指针`slow`左移。遍历完成后慢指针`slow`前面的元素就都是退格后保存下的字符，我们只需要比较`s`和`t`经过退格后保存的字符是否一一对应相等即可。

使用这种方法需要额外注意一下python中不允许对`str`类型的数据进行修改，因此我们要把字符串先转换成`List`类型的数据。

```python
class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        def backspace(s: List[str]) -> List[str]:
            fast, slow = 0, 0
            for fast in range(len(s)):
                if s[fast] != "#":
                    s[slow] = s[fast]
                    slow += 1
                elif slow > 0:
                    slow -= 1
            
            return s[:slow]
        
        return backspace(list(s)) == backspace(list(t))
```
{: .snippet}

## Reference

- [代码随想录: 数组](https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)