---
layout: article
title: 数组
key: leetcode-01
clipboard: true
aside:
  toc: true
sidebar:
  nav: LeetCode
---

## 二分查找

当题干中出现了**有序数组**和**无重复元素**时就可以考虑使用二分查找来进行解题。二分查找的框架是定义一个搜索区间`[left, right]`，然后利用中间元素`mid`来不断更新区间：

```python
left, right = 0, len(arr)-1

while left <= right:
    mid = left + (right-left) // 2

    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        left = mid + 1
    else:
        right = mid - 1
```

需要注意的是在更新区间端点时要把`left`和`right`更新为`mid + 1`和`mid - 1`。这是因为我们已经检查过中点`mid`对应的元素一定不是目标`target`，也就无需再考虑`mid`位置。

### 704. 二分查找

给定一个`n`个元素有序的（升序）整型数组`nums`和一个目标值`target`，写一个函数搜索`nums`中的 `target`，如果目标值存在返回下标，否则返回`-1`。

**示例1：**

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例2：**

```
输入: nums = [-1,0,3,5,9,12], target = 2     
输出: -1        
解释: 2 不存在 nums 中因此返回 -1        
```

**提示：**

- 你可以假设`nums`中的所有元素是不重复的。
- `n`将在`[1, 10000]`之间。
- `nums`的每个元素都将在`[-9999, 9999]`之间。

#### Solution

[题目链接](https://leetcode.cn/problems/binary-search/)：

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums)-1

        while left <= right:
            mid = left + (right-left) // 2

            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1

        return -1
```
{: .snippet}

### 35. 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为`O(log n)`的算法。

**示例 1：**

```
输入: nums = [1,3,5,6], target = 5
输出: 2
```

**示例 2：**

```
输入: nums = [1,3,5,6], target = 2
输出: 1
```

**示例 3：**

```
输入: nums = [1,3,5,6], target = 7
输出: 4
```

**提示：**

- 1 <= `nums.length` <= 10^4。
- -10^4 <= `nums[i]` <= 10^4。
- `nums`为**无重复元素**的**升序**排列数组。
- -10^4 <= `target` <= 10^4。

#### Solution

当`target`存在于`nums`数组中时使用标准的二分查找即可；而当`target`不在`nums`中时我们需要返回数组中首个大于`target`的元素位置，此时它即为退出搜索循环时`left`的位置。

[题目链接](https://leetcode.cn/problems/search-insert-position/)：

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums)-1
        
        while left <= right:
            mid = left + (right-left) // 2

            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        
        return left
```
{: .snippet}

### 34. 在排序数组中查找元素的第一个和最后一个位置

给你一个按照非递减顺序排列的整数数组`nums`，和一个目标值`target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值target，返回`[-1, -1]`。

你必须设计并实现时间复杂度为`O(log n)`的算法解决此问题。

**示例 1：**

```
输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
```

**示例 2：**

```
输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]
```

**示例 3：**

```
输入: nums = [], target = 0
输出: [-1,-1]
```

**提示：**

- 1 <= `nums.length` <= 10^5。
- -10^9 <= `nums[i]` <= 10^9。
- `nums`是一个非递减数组。
- -10^9 <= `target` <= 10^9。

#### Solution

当数组中有重复的`target`时，使用二分查找会得到重复区间中的某个位置。此时为了得到重复区间的边界，只需分别向左右进行搜索即可。

[题目链接](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)：

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if len(nums) == 0:
            return [-1, -1]
        
        idx = self.binarySearch(nums, target)
        if idx == -1:
            return [-1, -1]

        left, right = idx, idx
        while left-1 >= 0 and nums[left-1] == target:
            left -= 1

        while right+1 <= len(nums)-1 and nums[right+1] == target:
            right += 1
        
        return [left, right]
    
    def binarySearch(self, nums: List[int], target: int) -> int:        
        left, right = 0, len(nums)-1

        while left <= right:
            mid = left + (right-left) // 2

            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        
        return -1
```
{: .snippet}

### 69. x的平方根

给你一个非负整数`x`，计算并返回`x`的**算术平方根**。

由于返回类型是整数，结果只保留**整数部分**，小数部分将被**舍去**。

注意：不允许使用任何内置指数函数和算符，例如`pow(x, 0.5)`或者`x ** 0.5`。

**示例 1：**

```
输入: x = 4
输出: 2
```

**示例 2：**

```
输入: x = 8
输出: 2
解释: 8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
```

**提示：**

- 0 <= `x` <= 2^31 - 1。

#### Solution

使用二分法进行求解时我们需要稍微修改一下判断条件，当中点`mid`的平方小于等于`x`且`mid+1`的平方大于`x`时退出搜索。

[题目链接](https://leetcode.cn/problems/sqrtx/)：

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        def cond(xx):
            if xx*xx <= x and (xx+1)*(xx+1) > x:
                return True
            return False
        
        left, right = 0, x
        while left <= right:
            mid = left + (right-left) // 2

            if cond(mid):
                return mid
            elif mid*mid < x:
                left = mid+1
            else:
                right = mid-1
        
        return mid
```
{: .snippet}

当然更快的解法是使用牛顿法，迭代式为：

$$
\begin{aligned}
y &\leftarrow y - \frac{y^2-x}{2y} \\
&= \frac{y}{2} + \frac{x}{2y}
\end{aligned}
$$

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        y = x

        while y*y > x:
            y = y/2+x/(2*y)
            y = int(y)
        
        return y
```
{: .snippet}

## 双指针

## Reference

- [代码随想录: 数组](https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)