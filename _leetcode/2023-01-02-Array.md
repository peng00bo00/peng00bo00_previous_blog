---
layout: article
title: 数组
key: leetcode-01
clipboard: true
aside:
  toc: true
sidebar:
  nav: LeetCode
---

## 二分查找

当题干中出现了**有序数组**和**无重复元素**时就可以考虑使用二分查找来进行解题。二分查找的框架是定义一个搜索区间`[left, right]`，然后利用中间元素`mid`来不断更新区间：

```python
left, right = 0, len(arr)-1

while left <= right:
    mid = (left+right) // 2

    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        left = mid + 1
    else:
        right = mid - 1
```

需要注意的是在更新区间端点时要把`left`和`right`更新为`mid + 1`和`mid - 1`。这是因为我们已经判断过中点`mid`对应的元素一定不是目标`target`，也就无需再考虑`mid`位置。

### 704. 二分查找

给定一个`n`个元素有序的（升序）整型数组`nums`和一个目标值`target`，写一个函数搜索`nums`中的 `target`，如果目标值存在返回下标，否则返回`-1`。

示例1：

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

示例2：

```
输入: nums = [-1,0,3,5,9,12], target = 2     
输出: -1        
解释: 2 不存在 nums 中因此返回 -1        
```

提示：

- 你可以假设`nums`中的所有元素是不重复的。
- `n`将在`[1, 10000]`之间。
- `nums`的每个元素都将在`[-9999, 9999]`之间。

#### Solution

[题目链接](https://leetcode.cn/problems/binary-search/)：

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums)-1

        while left <= right:
            mid = left + (right-left) // 2

            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1

        return -1
```
{: .snippet}

## 双指针

## Reference

- [代码随想录: 数组](https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)