---
layout: article
title: 数组
key: leetcode-01
clipboard: true
aside:
  toc: true
sidebar:
  nav: LeetCode
---

## 二分查找

当题干中出现了**有序数组**和**无重复元素**时就可以考虑使用二分查找来进行解题。二分查找的框架是定义一个搜索区间`[left, right]`，然后利用中间元素`mid`来不断更新区间：

```python
left, right = 0, len(arr)-1

while left <= right:
    mid = left + (right-left) // 2

    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        left = mid + 1
    else:
        right = mid - 1
```

需要注意的是在更新区间端点时要把`left`和`right`更新为`mid + 1`和`mid - 1`。这是因为我们已经检查过中点`mid`对应的元素一定不是目标`target`，也就无需再考虑`mid`位置。

### 704. 二分查找

给定一个`n`个元素有序的（升序）整型数组`nums`和一个目标值`target`，写一个函数搜索`nums`中的 `target`，如果目标值存在返回下标，否则返回`-1`。

**示例1：**

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例2：**

```
输入: nums = [-1,0,3,5,9,12], target = 2     
输出: -1        
解释: 2 不存在 nums 中因此返回 -1        
```

**提示：**

- 你可以假设`nums`中的所有元素是不重复的。
- `n`将在`[1, 10000]`之间。
- `nums`的每个元素都将在`[-9999, 9999]`之间。

#### Solution

[题目链接](https://leetcode.cn/problems/binary-search/)：

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums)-1

        while left <= right:
            mid = left + (right-left) // 2

            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1

        return -1
```
{: .snippet}

### 35. 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为`O(log n)`的算法。

**示例 1：**

```
输入: nums = [1,3,5,6], target = 5
输出: 2
```

**示例 2：**

```
输入: nums = [1,3,5,6], target = 2
输出: 1
```

**示例 3：**

```
输入: nums = [1,3,5,6], target = 7
输出: 4
```

**提示：**

- 1 <= `nums.length` <= 10<sup>4</sup>。
- -10<sup>4</sup> <= `nums[i]` <= 10<sup>4</sup>。
- `nums`为**无重复元素**的**升序**排列数组。
- -10<sup>4</sup> <= `target` <= 10<sup>4</sup>。

#### Solution

当`target`存在于`nums`数组中时使用标准的二分查找即可；而当`target`不在`nums`中时我们需要返回数组中首个大于`target`的元素位置，此时它即为退出搜索循环时`left`的位置。

[题目链接](https://leetcode.cn/problems/search-insert-position/)：

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums)-1
        
        while left <= right:
            mid = left + (right-left) // 2

            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        
        return left
```
{: .snippet}

### 34. 在排序数组中查找元素的第一个和最后一个位置

给你一个按照非递减顺序排列的整数数组`nums`，和一个目标值`target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值target，返回`[-1, -1]`。

你必须设计并实现时间复杂度为`O(log n)`的算法解决此问题。

**示例 1：**

```
输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
```

**示例 2：**

```
输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]
```

**示例 3：**

```
输入: nums = [], target = 0
输出: [-1,-1]
```

**提示：**

- 1 <= `nums.length` <= 10<sup>5</sup>。
- -10<sup>9</sup> <= `nums[i]` <= 10<sup>9</sup>。
- `nums`是一个非递减数组。
- -10<sup>9</sup> <= `target` <= 10<sup>9</sup>。

#### Solution

当数组中有重复的`target`时，使用二分查找会得到重复区间中的某个位置。此时为了得到重复区间的边界，只需分别向左右进行搜索即可。

[题目链接](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)：

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if len(nums) == 0:
            return [-1, -1]
        
        idx = self.binarySearch(nums, target)
        if idx == -1:
            return [-1, -1]

        left, right = idx, idx
        while left-1 >= 0 and nums[left-1] == target:
            left -= 1

        while right+1 <= len(nums)-1 and nums[right+1] == target:
            right += 1
        
        return [left, right]
    
    def binarySearch(self, nums: List[int], target: int) -> int:        
        left, right = 0, len(nums)-1

        while left <= right:
            mid = left + (right-left) // 2

            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        
        return -1
```
{: .snippet}

### 69. x的平方根

给你一个非负整数`x`，计算并返回`x`的**算术平方根**。

由于返回类型是整数，结果只保留**整数部分**，小数部分将被**舍去**。

注意：不允许使用任何内置指数函数和算符，例如`pow(x, 0.5)`或者`x ** 0.5`。

**示例 1：**

```
输入: x = 4
输出: 2
```

**示例 2：**

```
输入: x = 8
输出: 2
解释: 8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
```

**提示：**

- 0 <= `x` <= 2<sup>31</sup> - 1。

#### Solution

使用二分法进行解题时我们需要稍微修改一下判断条件，当中点`mid`的平方小于等于`x`且`mid+1`的平方大于`x`时退出搜索。

[题目链接](https://leetcode.cn/problems/sqrtx/)：

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        def cond(xx):
            if xx*xx <= x and (xx+1)*(xx+1) > x:
                return True
            return False
        
        left, right = 0, x
        while left <= right:
            mid = left + (right-left) // 2

            if cond(mid):
                return mid
            elif mid*mid < x:
                left = mid+1
            else:
                right = mid-1
        
        return mid
```
{: .snippet}

当然更快的解法是使用牛顿法，迭代式为：

$$
\begin{aligned}
y &\leftarrow y - \frac{y^2-x}{2y} \\
&\leftarrow \frac{y}{2} + \frac{x}{2y}
\end{aligned}
$$

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        y = x

        while y*y > x:
            y = y/2+x/(2*y)
            y = int(y)
        
        return y
```
{: .snippet}

### 367. 有效的完全平方数

给你一个正整数`num`。如果`num`是一个完全平方数，则返回`true`，否则返回`false`。

**完全平方数**是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。

不能使用任何内置的库函数，如`sqrt`。

**示例 1：**

```
输入: num = 16
输出: true
解释: 返回 true ，因为 4 * 4 = 16 且 4 是一个整数。
```

**示例 2：**

```
输入: num = 14
输出: false
解释: 返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。
```

**提示：**

- 1 <= `num` <= 2<sup>31</sup> - 1。

#### Solution

[题目链接](https://leetcode.cn/problems/valid-perfect-square/)：

```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        if num == 1:
            return True

        left, right = 1, num-1

        while left <= right:
            mid = left + (right-left) // 2
            mid2= mid*mid

            if mid2 == num:
                return True
            elif mid2 < num:
                left = mid + 1
            else:
                right = mid - 1
        
        return False
```
{: .snippet}

除了二分法之外，更快的方法是利用完全平方数的性质。实际上完全平方数可以表示为等差数列的和：

- 1×1 = 1
- 2×2 = 1 + 3
- 3×3 = 1 + 3 + 5
- 4×4 = 1 + 3 + 5 + 7
- ...
- n×n = 1 + 3 + ... + (2n-1)

因此我们只需要判断`num`是否能够分解为这样的等差数列即可。

```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        i = 1
        while num > 0:
            num -= i
            i += 2
        
        return num == 0
```
{: .snippet}

## 双指针

双指针的基本思想是使用两个指针来遍历数组，很多需要使用二重循环的问题通过双指针就只需一次循环就能解决，这样算法的复杂度就由`O(n²)`降低为`O(n)`。

### 27. 移除元素

给你一个数组`nums`和一个值`val`，你需要**原地**移除所有数值等于`val`的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用`O(1)`额外空间并**原地**修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**示例 1：**

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

**示例 2：**

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
```

**提示：**

- 0 <= `nums.length` <= 100。
- 0 <= `nums[i]` <= 50。
- 0 <= `val` <= 100。

#### Solution

这个问题可以使用快慢两个指针来进行处理：快指针`fast`直接对数组进行遍历，而慢指针`slow`则对应不包含`val`的新数组。当快指针`fast`遇到`val`时保持慢指针`slow`不动，这样可以保证新数组不会包含`val`；否则就把`fast`位置的值赋给`slow`，这样就更新了数组；最后慢指针`slow`的位置即为所需的新数组长度。整个算法过程可以可视化如下：

<div align=center>
<img src="https://camo.githubusercontent.com/a701d49e9f64bd71f08a19276679f49d971d765e07402b3982f9b0ab63969f45/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676e7472647336723539673330647530396d6e70642e676966" width="50%">
</div>

[题目链接](https://leetcode.cn/problems/remove-element/)：

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        fast, slow = 0, 0

        for fast in range(len(nums)):
            if nums[fast] != val:
                nums[slow] = nums[fast]
                slow += 1

        return slow
```
{: .snippet}

### 283. 移动零

给定一个数组`nums`，编写一个函数将所有`0`移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意**，必须在不复制数组的情况下原地对数组进行操作。

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2：**

```
输入: nums = [0]
输出: [0]
```

**提示：**

- 1 <= `nums.length` <= 10<sup>4</sup>。
- -2<sup>31</sup> <= `nums[i]` <= 2<sup>31</sup>-1。

#### Solution

解法与[27. 移除元素](https://peng00bo00.github.io/leetcode/2023-01-02-Array.html#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0)类似，同样使用快慢两个指针来对数组进行遍历。当快指针`fast`遇到`0`时保持慢指针不动，否则交换两个指针指向的元素并且移动慢指针`slow`。

[题目链接](https://leetcode.cn/problems/move-zeroes/)：

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """

        slow, fast = 0, 0

        for fast in range(len(nums)):
            if nums[fast] != 0:
                nums[slow], nums[fast] = nums[fast], nums[slow]
                slow += 1
```
{: .snippet}

### 844. 比较含退格的字符串

给定`s`和`t`两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回`true`。`#`代表退格字符。

**注意：**如果对空文本输入退格字符，文本继续为空。

**示例 1：**

```
输入：s = "ab#c", t = "ad#c"
输出：true
解释：s 和 t 都会变成 "ac"。
```

**示例 2：**

```
输入：s = "ab##", t = "c#d#"
输出：true
解释：s 和 t 都会变成 ""。
```

**示例 3：**

```
输入：s = "a#c", t = "b"
输出：false
解释：s 会变成 "c"，但 t 仍然是 "b"。
```

**提示：**

- 1 <= `s.length`, `t.length` <= 200。
- `s`和`t`只含有小写字母以及字符`#`。

#### Solution

利用双指针可以在`O(1)`的空间复杂度来解决这个题目。由于退格字符`#`不会影响到它后面的字符，我们可以从后向前对两个字符串进行遍历。具体来说我们使用`i`和`j`两个指针分别指向两个字符串的末尾，`skipI`和`skipJ`分别表示字符串中中遍历到的退格。算法整体思路如下：

1. 如果字符串中当前的字符为`#`则向前移动`i`或者`j`，对应的`skipI`和`skipJ`需要进行自增。
2. 如果字符串中当前的字符不是`#`，则根据`skipI`和`skipJ`是否为选择0继续向前移动或是停止。
3. 比较两个字符串当前的最末位`s[i]`和`t[j]`，如果不相等则返回`False`，否则回到第1步继续进行比较。

<div align=center>
<img src="https://camo.githubusercontent.com/7e8b6ba5fb7b3c53a9a8e1c882e4f7503b7a2cc303c422dffb4de51920dd9c0e/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f3834342ee6af94e8be83e590abe98080e6a0bce79a84e5ad97e7aca6e4b8b22e676966" width="50%">
</div>

[题目链接](https://leetcode.cn/problems/backspace-string-compare/)：

```python
class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        i, j = len(s)-1, len(t)-1
        skipI, skipJ = 0, 0

        while i >= 0 or j >= 0:
            ## back move i
            while i >= 0:
                if s[i] == "#":
                    i -= 1
                    skipI += 1
                else:
                    if skipI > 0:
                        i -= 1
                        skipI -= 1
                    else:
                        break
            
            ## back move j
            while j >= 0:
                if t[j] == "#":
                    j -= 1
                    skipJ += 1
                else:
                    if skipJ > 0:
                        j -= 1
                        skipJ -= 1
                    else:
                        break
            
            if i >= 0 and j >= 0:
                if s[i] != t[j]:
                    return False
            elif i >= 0 or j >= 0:
                return False
            
            i -= 1
            j -= 1
        
        return True
```
{: .snippet}

除此之外，也可以利用快慢指针来模拟字符串的退格过程。当快指针`fast`遇到非`#`字符时将它指向的元素赋给慢指针`slow`，然后将慢指针右移；否则将慢指针`slow`左移。遍历完成后慢指针`slow`前面的元素就都是退格后保存下的字符，我们只需要比较`s`和`t`经过退格后保存的字符是否一一对应相等即可。

使用这种方法需要额外注意一下python中不允许对`str`类型的数据进行修改，因此我们要把字符串先转换成`List`类型的数据。

```python
class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        def backspace(s: List[str]) -> List[str]:
            fast, slow = 0, 0
            for fast in range(len(s)):
                if s[fast] != "#":
                    s[slow] = s[fast]
                    slow += 1
                elif slow > 0:
                    slow -= 1
            
            return s[:slow]
        
        return backspace(list(s)) == backspace(list(t))
```
{: .snippet}

### 977.有序数组的平方

给你一个按**非递减顺序**排序的整数数组`nums`，返回**每个数字的平方**组成的新数组，要求也按**非递减顺序**排序。

**示例 1：**

```
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```

**示例 2：**

```
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
```

**提示：**

- 1 <= `nums.length` <= 10<sup>4</sup>。
- -10<sup>4</sup> <= `nums[i]` <= 10<sup>4</sup>。
- `nums`已按**非递减顺序**排序。

#### Solution

本题的直接解法是首先构造`nums`中元素平方构成的数组然后进行排序，此时的算法复杂度为`O(n)+O(log n)`。而利用双指针则只需要进行一次遍历即可：注意到`nums`数组平方的最大值一定在两端点，我们只需要利用`left`和`right`两个指针分别指向作业两端然后向中间进行遍历，每次选择平方较大的数将其赋给新数组的末尾即可。此时的算法复杂度为`O(n)`。

<div align=center>
<img src="https://camo.githubusercontent.com/3416a4d2775067bebeb7fe40955f4e9a59f6281c050bad8266853ac218b04685/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f3937372e2545362539432538392545352542412538462545362539352542302545372542422538342545372539412538342545352542392542332545362539362542392e676966" width="60%">
</div>

[题目链接](https://leetcode.cn/problems/squares-of-a-sorted-array/)：

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        left, right = 0, len(nums)-1
        i = len(nums)-1
        ret = [-1]*len(nums)

        while left <= right:
            left2 = nums[left]*nums[left]
            right2= nums[right]*nums[right]

            if left2 < right2:
                ret[i] = right2
                right -= 1
            else:
                ret[i] = left2
                left += 1
            
            i -= 1
        
        return ret
```
{: .snippet}

## 滑动窗口

### 209. 长度最小的子数组

给定一个含有`n`个正整数的数组和一个正整数`target`。

找出该数组中满足其和`≥ target`的长度最小的**连续子数组**`[numsl, numsl+1, ..., numsr-1, numsr]`，并返回其长度。如果不存在符合条件的子数组，返回`0`。

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例 3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

**提示：**

- 1 <= `target` <= 10<sup>9</sup>。
- 1 <= `nums.length` <= 10<sup>5</sup>。
- 1 <= `nums[i]` <= 10<sup>5</sup>。

#### Solution

本题的暴力解法是利用二重循环来构造所有可能的子列并计算子列之和，其算法复杂度为`O(n²)`。而利用双指针则可以构造一个滑动窗口`[start, end]`，同时利用变量`s`保存区间内元素之和。进行遍历时每次先向右移动`end`指针，然后右移`left`直到`s`小于target。右移`left`时每次减去`nums[left]`从而保证`s`等于区间内元素之和，同时需要更新满足`s`大于等于`target`条件的区间长度。

<div align=center>
<img src="https://camo.githubusercontent.com/dd84aee84237ebb78cf7ffde58803dc03350a4071d0981b8add65d9c59199ac4/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f3230392e2545392539352542462545352542412541362545362539432538302545352542302538462545372539412538342545352541442539302545362539352542302545372542422538342e676966" width="50%">
</div>

[题目链接](https://leetcode.cn/problems/minimum-size-subarray-sum/)：

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        start, end = 0, 0
        s = 0
        length = float("inf")

        for end in range(len(nums)):
            s += nums[end]
            while s >= target:
                length = min(length, end-start+1)
                s -= nums[start]
                start += 1
        
        return 0 if length == float("inf") else length
```
{: .snippet}

### 904. 水果成篮

你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组`fruits`表示，其中`fruits[i]`是第`i`棵树上的水果**种类** 。

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

- 你只有**两个**篮子，并且每个篮子只能装**单一类型**的水果。每个篮子能够装的水果总量没有限制。
- 你可以选择任意一棵树开始采摘，你必须从**每棵**树（包括开始采摘的树）上**恰好摘一个水果**。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
- 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。

给你一个整数数组fruits，返回你可以收集的水果的**最大**数目。

**示例 1：**

```
输入：fruits = [1,2,1]
输出：3
解释：可以采摘全部 3 棵树。
```

**示例 2：**

```
输入：fruits = [0,1,2,2]
输出：3
解释：可以采摘 [1,2,2] 这三棵树。
如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。
```

**示例 3：**

```
输入：fruits = [1,2,3,2,2]
输出：4
解释：可以采摘 [2,3,2,2] 这四棵树。
如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。
```

**示例 4：**

```
输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]
输出：5
解释：可以采摘 [1,2,1,1,2] 这五棵树。
```

**提示：**

- 1 <= `fruits.length` <= 10<sup>5</sup>。
- 0 <= `fruits[i]` <= `fruits.length`。

#### Solution

本题的解法是使用双指针构造滑动窗口`[start, end]`，同时使用哈希表`bag`来保存窗口中不同水果的个数。我们每次右移一下`end`指针，然后更新`bag`中的水果数量。如果`bag`中的键值超过2个，说明我们需要右移`start`指针直到键值为2。这里需要注意的是当`bag`中某个键值对应的记数为`0`时需要将该键值删除。

[题目链接](https://leetcode.cn/problems/fruit-into-baskets/)：

```python
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        start, end = 0, 0
        bag = {}
        length = 0

        for end, x in enumerate(fruits):
            bag[x] = bag.get(x, 0)+1

            while len(bag) > 2:
                bag[fruits[start]] -= 1

                if bag[fruits[start]] == 0:
                    bag.pop(fruits[start])
                
                start += 1

            length = max(length, end-start+1)

        return length
```
{: .snippet}

## Reference

- [代码随想录: 数组](https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)